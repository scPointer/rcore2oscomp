{"./":{"url":"./","title":"实验简介","keywords":"","body":"从 rCore-Tutorial 到实际应用 在这里可以看到本项目的在线文档。 本教程是 rCore-Tutorial 的后续教程，希望能帮助大家从 rCore-Tutorial 以及其他 Rust 内核出发，构建一个可运行原生 Linux 应用、拥有更强大功能的内核。如果你是希望参加全国大学生计算机系统能力大赛操作系统设计赛的同学，可以通过本教程学习如何构建自己的内核；如果你是其他 Rust 开发者，也可以通过本教程扩展 rCore-Tutorial，用学到的知识为开源社区做贡献。 本教程的各个实验间不是连续的。我们会选择内核开发中的一些小切片，以它们为例设计代码量适中的实验，引导大家在OS比赛中的开发。如果说 rCore-Tutorial 是十层居民楼的毛坯房，需要大家通过 5 个实验去“装修”，那么本教程就像是一个个更高楼房的地基，指引大家从这里开始建造摩天大楼。 目前本教程被用作开源操作系统训练营（见 github 首页说明）的实践项目。 为什么会有这个教程？ rCore-Tutorial 是一个用 Rust 写操作系统的教程。当你做完这个教程，就已经获得了一个支持文件系统、线程等特性，包含约 50 个 syscall 的操作系统内核。 不过，如果想要进一步扩展这个内核，就会出现其他问题： rCore-Tutorial 的文件系统、测例自成一体，最后完成的内核也只能运行它自己的文件系统、跑自己的测例，和通用测例集乃至真正的 Linux 应用不兼容。 syscall 并不完全和 POSIX 接口兼容。部分 syscall 是来自 Zircon，还有一部分是为了实验考察而添加的仅用于实验本身的 syscall 模块划分不完善，模块化程度不高，沿用框架开发到后期会比较痛苦 有经验的同学可以自行重构 rCore-Tutorial，或者重新写一个内核来参加OS比赛。但大多数只学过 rCore-Tutorial 的同学来说，这样的重构并不在它教程的范围内，因此修改 rCore-Tutorial 就成了参赛的一道门槛。 本教程的目的是帮助大家跨过这道门槛，能够将更多精力投入到内核本身的开发中。 实验形式 本教程中的实验参考 rCore-Tutorial，分为代码实验和思考题，每一章节需要提交报告。但也有以下不同： 整个教程没有统一的仓库，部分实验需要使用 rCore-Tutorial 仓库，部分实验自带另一个仓库。 实验参考了 rustlings 教程的形式，边做边学，跟随教程指引就可以完成大部分代码工作，而章节末尾的代码实验预期会需要更少的时间。 "},"docs/lab1/intro.html":{"url":"docs/lab1/intro.html","title":"实验概述","keywords":"","body":"运行裸机 C 程序 建议先阅读 rCore-Tutorial ch6 及之前的内容再做这个实验。 rCore-Tutorial 有许多版本的指导书，详细的在这里，如果你没有太多时间，也可以阅读简略版本的指导书。 实验需要使用你在 rCore-Tutorial 实验中的仓库，但不依赖于你在 rCore-Tutorial 中完成的任何作业代码。你可以用自己的 rCore-Tutorial ch8 分支来做这个实验中的代码修改，也可以用没有修改过的 ch7 分支。 如果你还没有自己的 rCore-Tutorial 仓库，可以选择以下两种方式之一 通过邀请链接创建仓库： https://classroom.github.com/a/AFBsVzHi 进入这个仓库：https://github.com/LearningOS/rCore-Tutorial-Code-2023A/，在右上角点击绿色按钮 Use this template，然后点击 Create a new repository，这相当于 fork 了这个仓库到你的用户名下。 实验准备 本实验需要用到交叉编译的工具链：https://musl.cc/riscv64-linux-musl-cross.tgz。下载解压后将里面的 bin 目录放到你的 PATH 中，然后尝试使用以下命令 riscv64-linux-musl-gcc --version 来检查是否安装成功。 如果忘了怎么安装这类包，可以看rCore-Tutorial 指导书第0章环境配置中安装 Qemu 模拟器一节，操作是类似的。 实验概述 在往年的 rCore-Tutorial 实验中，有些同学会有这样一种感受：整个 rCore-Tutorial 是一个完整的项目，从内核到测例到文件系统都是用 Rust 连接的，修改任何一部分都需要做额外的兼容。就像下面这样： 但其实这中间都是二进制接口，只是被实验仓库里完善的脚本掩盖了。我们可以任意更换这其中的每个部分，而不需要做另外的适配： 在本章中，我们将回顾用户程序的编译与加载流程，然后使用一个极简的 C 用户程序库代替 rCore-Tutorial 原有的 /user 测例，并修改上面这套编译、打包、加载的流程中的各个 Makefile，让原本只支持 rCore-Tutorial 自带的 Rust 测例的内核运行一个从 C 语言编译的应用程序。 在实验之后 运行 C 用户程序是OS比赛初赛的第一步。如果你正在参赛或者准备参赛，那么在完成这个实验之后，还有下面这些工作要做 尝试通过比赛初赛测例库 比赛初赛测例库 可以直接访问，通过它也就通过了初赛。这个测例库比当前实验里要稍微复杂一些，但功能上相比 rCore-Tutorial 不会有太大变化。注意比赛的 syscall 规范和 rCore-Tutorial 的会有细微差别。 更换一个 FAT32 类型的文件系统 这是比赛初赛的要求。你可以自己写一个，也可以参考往年获奖作品的实现，也可以使用现有的开源项目，比如rust-fatfs。 FAT32 的好处在于，它是一个公共的文件系统格式。因此可以直接用 dd 和 mkfs.vfat 命令创建一个镜像（具体要求看比赛），然后直接在本地挂载它就可以往里塞文件了，完全不需要 easy-fs-fuse： # in makefile -mkdir temp sudo mount ./fs.img temp -sudo cp -r -a ./testcases/* ./temp/ sudo umount ./fs.img rmdir temp 这段命令把 fs.img挂载到 temp 文件夹中，然后把 testcases 里的所有测例都塞了进去，实际上和 easy-fs-fuse 做的事情是一样的。 顺便一提，- 开头的命令会如果执行失败，则 makefile 仍然继续进行下面的命令。 第一条指令的 - 是因为目录本身可能已存在，第三条指令的 - 开头是因为本地文件系统中可能有符号链接，它们在被复制进不支持链接的 FAT32 时会报错。无论如何，我们希望第三行指令执行完成后必须执行第四行指令 umount ./fs.img ，也就是取消 fs.img 的挂载。否则宿主机上可能会因为一次 make 失败而永远挂着这么一个文件系统。 考虑离线编译 截至目前，比赛的评测机不支持联网。因此，你可能需要为内核准备一个“离线”编译模式。具体来说，需要在内核 cargo build 的地方加上参数 --offline，然后在这个模式下将所有评测机不支持的依赖库拉到项目里。可以用 Makefile 变量等方式来控制这个参数。 如果本地网络不是很好的话，这种离线编译方式也许能为本地调试节省一些时间。毕竟，编译 Rust 项目时卡在拉取依赖库上实在是太常见了。 "},"docs/lab1/toelf.html":{"url":"docs/lab1/toelf.html","title":"编译到二进制代码","keywords":"","body":"编译到二进制文件 在 ch6 中，rCore-Tutorial 指导书详细介绍了应用程序运行时如何读写文件、文件系统 easy-fs 的实现以及内核如何与文件系统交互。但对于用户程序如何在编译后被塞进文件系统这个过程，指导书讲得比较粗略，容易让大家以为用户程序和文件系统是以某种“魔法”联系在一起的。 现在我们先暂时跳出内核，破解这一层魔法。 分析 user/Makefile 在 user文件夹下，运行 make build CHAPTER=8 BASE=2 这一步会将所有 ch8 及之前的测例编译后放一份到 user/build/elf/ 中，然后将每个应用删除 ELF header 符号得到纯二进制的镜像，放到 user/build/bin/，如同 ch2 “实现应用程序”一节介绍的那样。但和 ch2 不同的是，这些ELF文件会被放到文件系统里，而不是直接链接进内核。 我们可以看 user/Makefile 这个文件了解 make build 时发生了什么： ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) binary: @echo $(ELFS) @if [ ${CHAPTER} -gt 3 ]; then \\ cargo build $(MODE_ARG) ;\\ else \\ CHAPTER=$(CHAPTER) python3 build.py ;\\ fi @$(foreach elf, $(ELFS), \\ $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf)); \\ cp $(elf) $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.elf, $(elf));) ...... pre: @mkdir -p $(BUILD_DIR)/bin/ @mkdir -p $(BUILD_DIR)/elf/ @mkdir -p $(BUILD_DIR)/app/ @mkdir -p $(BUILD_DIR)/asm/ @$(foreach t, $(APPS), cp $(t) $(BUILD_DIR)/app/;) build: clean pre binary @$(foreach t, $(ELFS), cp $(t).bin $(BUILD_DIR)/bin/;) @$(foreach t, $(ELFS), cp $(t).elf $(BUILD_DIR)/elf/;) clean: @cargo clean @rm -rf $(BUILD_DIR) build: clean pre binary 告诉我们 build 这个任务依赖于后面的三个任务，所以只需要把这几个任务单独拉出来看： ELFS 定义了所有测例对应的 ELF 文件。patsubst 这个命令的意思是，把 $(APPS) 中每一个形如 $(APP_DIR)/%.rs 这样的字符串找出来，把它替换成 $(TARGET_DIR)/%（符号 % 对应前面 $(APP_DIR)/%.rs 那里的 % 表示的字符串），然后把所有替换后的串交给 ELFS。比如 src/bin/ch6_file0.rs 会被替换成 target/riscv64gc-unknown-none-elf/release/ch6_file0。 clean 删除了 cargo 也就是 Rust 编译后的临时文件，然后删除 build 目录 pre 创建了 build 目录以及下属的几个子目录，app elf bin 分别存放测例代码、测例编译后的 ELF 文件、ELF 文件删除元信息后的纯可执行文件。然后把代码复制一份，存到 app 目录下。 asm 下是空的，它会在另一个叫 disasm 的任务被用到 binary 首先用 if [ ${CHAPTER} -gt 3 ]; 检查编译的章节是否大于 3，大于 3 则使用 Rust 的编译器 cargo 编译，否则使用 python。随后，它会把 $(ELFS) 中所有文件的调试段删掉，命名为对饮的 .bin 文件。然后把 $(ELFS) 中所有文件复制一份，命名为对应的 .elf 文件。 如果你还记得的话，在 ch3 及之前我们的内核是“批处理操作系统”，所以需要依赖其他程序（代码框架里用的 python）做链接 最后 build 任务会把上一步 binary 生成的 .bin 和 .elf 文件分别复制一份到 $(BUILD_DIR)/bin/ 目录和 $(BUILD_DIR)/elf/ 目录。 检查二进制文件的内容 这一部分简要介绍编译生成的二进制文件的内容，更详细的信息可以参照 rCore-Tutorial 指导书的附录 B。 在 user/build/elf/ 下运行 rust-objdump --arch-name=riscv64 -ld ch6_file0.elf > debug.S，可以在文件中看到像这样的输出 ch6_file0.elf: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 : ; _start(): 0: 0d 71 addi sp, sp, -352 2: 86 ee sd ra, 344(sp) 4: 2e fc sd a1, 56(sp) 6: aa e0 sd a0, 64(sp) 8: aa f5 sd a0, 232(sp) a: ae f9 sd a1, 240(sp) c: 97 00 00 00 auipc ra, 0 10: e7 80 20 5f jalr 1522(ra) ...... 这是一个 elf 格式的可执行文件。如果你看过 rCore-Tutorial 指导书的附录 B 的话可能会对这个形式有印象。这个测例的可执行文件与整个 OS 的可执行文件并没有什么不同。例如你可以在文件中找到： _start 是整个程序的入口，也就是 os/src/task/process.rs 中调用 MemorySet::from_elf 拿到的 entry_point。 文件中的 ecall 指令实际上就是内核中看到的 syscall 调用的来源。在 ecall 指令之前通常在操作 a7 以及 a0 a1 a2 等寄存器，这就是内核在 os/src/trap/mod.rs:trap_handler 中看到的 let result = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12], cx.x[13]]); 所调用的几个寄存器。 下一节我们会详细带大家分析一个类似文件的内容。 虽然我们用 Rust 编译了它，并且用 rust-objdump区查看它的反汇编，但到这一步这个文件已经和 Rust 无关了。我们可以尝试改用前面安装的交叉编译工具链，运行 riscv64-linux-musl-objdump -ld ch6_file0.elf > debug.S，可以在文件中看到这样的输出 ch6_file0.elf: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 : _start(): 0: 710d addi sp,sp,-352 2: ee86 sd ra,344(sp) 4: fc2e sd a1,56(sp) 6: e0aa sd a0,64(sp) 8: f5aa sd a0,232(sp) a: f9ae sd a1,240(sp) c: 00000097 auipc ra,0x0 10: 5f2080e7 jalr 1522(ra) # 5fe ...... 虽然排版上略有不同，且对函数调用地址给出了注释信息，但二进制文件本身是相同的。这意味着，我们可以用交叉编译工具链中的 gcc 编译一个 C 程序，把它塞到文件系统镜像里，它应该也能像 user 库里的 Rust 测例一样正常运行。不过这里还有一些细节问题，我们之后再讲这件事。 "},"docs/lab1/clib.html":{"url":"docs/lab1/clib.html","title":"测例库介绍","keywords":"","body":"测例库介绍 从这里可以获取到本次实验需要使用的用户程序。你需要把 lab1 分支下的 testcases 目录放到当前实验（也就是 2023a-rcore- 开头的这个项目）的根目录下，在 testcases 目录下运行 make build 即可在 testcases/build/ 下获得 42 hello两个二进制文件。 测例里都有什么 这是一个极简的测例库，可以编译不依赖于 libc 的 C 程序。事实上，它对标的是比赛初赛测例库（ https://github.com/oscomp/testsuits-for-oskernel/tree/master/riscv-syscalls-testing ）的超级简化版。 我们可以像上一节一样，在 build 目录下使用 riscv64-linux-musl-objdump -ld 42 > debug.S 检查这个可执行文件的内容。相对于其他汇编来说，其实它非常短，例如用标准库编译一个 hello world 有大概 5000 行。 其中的每一行，例如 100b0: 1141 addi sp,sp,-16 表示这一条指令的地址在 100b0，数值是 1141，这个数值的含义是一条 RISC-V 指令 addi sp,sp,-16。读懂里面发生的每一件事可能需要有一点 RISC-V 汇编语言基础，但不懂也没关系，我们会在代码下面解释它的内容： 42: file format elf64-littleriscv Disassembly of section .text: 00000000000100b0 : main(): 100b0: 1141 addi sp,sp,-16 100b2: e422 sd s0,8(sp) 100b4: 0800 addi s0,sp,16 100b6: 02a00793 li a5,42 100ba: 853e mv a0,a5 100bc: 6422 ld s0,8(sp) 100be: 0141 addi sp,sp,16 100c0: 8082 ret 00000000000100c2 : __start_main(): 100c2: 7179 addi sp,sp,-48 100c4: f406 sd ra,40(sp) 100c6: f022 sd s0,32(sp) 100c8: 1800 addi s0,sp,48 100ca: fca43c23 sd a0,-40(s0) 100ce: fd843783 ld a5,-40(s0) 100d2: 639c ld a5,0(a5) 100d4: fef42623 sw a5,-20(s0) 100d8: fd843783 ld a5,-40(s0) 100dc: 07a1 addi a5,a5,8 100de: fef43023 sd a5,-32(s0) 100e2: fec42783 lw a5,-20(s0) 100e6: fe043583 ld a1,-32(s0) 100ea: 853e mv a0,a5 100ec: fc5ff0ef jal ra,100b0 100f0: 87aa mv a5,a0 100f2: 853e mv a0,a5 100f4: 09c000ef jal ra,10190 00000000000100f8 : __syscall1(): 100f8: 1101 addi sp,sp,-32 100fa: ec22 sd s0,24(sp) 100fc: 1000 addi s0,sp,32 100fe: fea43423 sd a0,-24(s0) 10102: feb43023 sd a1,-32(s0) 10106: fe843883 ld a7,-24(s0) 1010a: fe043503 ld a0,-32(s0) 1010e: 00000073 ecall 10112: 87aa mv a5,a0 10114: 853e mv a0,a5 10116: 6462 ld s0,24(sp) 10118: 6105 addi sp,sp,32 1011a: 8082 ret ...... 0000000000010190 : exit(): 10190: 1101 addi sp,sp,-32 10192: ec06 sd ra,24(sp) 10194: e822 sd s0,16(sp) 10196: 1000 addi s0,sp,32 10198: 87aa mv a5,a0 1019a: fef42623 sw a5,-20(s0) 1019e: fec42783 lw a5,-20(s0) 101a2: 85be mv a1,a5 101a4: 05d00513 li a0,93 101a8: f51ff0ef jal ra,100f8 101ac: 0001 nop 101ae: 60e2 ld ra,24(sp) 101b0: 6442 ld s0,16(sp) 101b2: 6105 addi sp,sp,32 101b4: 8082 ret 00000000000101b6 : _start(): 101b6: 850a mv a0,sp 101b8: b729 j 100c2 _start 是整个程序的入口，它会将 sp 复制到 a0，相当于函数参数，然后调用 __start_main。这个参数并不直接等价于我们熟知的 argc 或argv，我们下面再详细介绍。 __start_main 是一个库提供的初始化函数。它初始化完成后，会调用 C 代码里用户程序自己的 main 函数。 main函数只是返回了一个 42，然后 __start_main 调用了 exit exit 其实相当于 sys_exit，也就是大家在 ch3 接触到的第一个 syscall，用于退出用户程序。在这段汇编中，它填好参数后会调用 __syscall1 最后 __syscall1 通过 ecall 陷入内核，通知内核这个用户程序结束了，且返回值是 42。ecall 后面的代码不会被执行到。 也可以直接看 C 的源代码。其中比较关键的是 lib\\main.c： int __start_main(long *p) { int argc = p[0]; char **argv = (void *)(p+1); exit(main(argc, argv)); return 0; } 其中输入参数 p 是 _start 调用 __start_main 时给的，实际上就是初始的用户栈指针。 main.c 中将初始用户栈指针 p 指向的值设为 argc，然后将 p+1 的值设为 argv。也就是说，用户栈上的空间大致是这样的 position content size (bytes) ------------------------------------------------------------------------ stack pointer -> [ argc = number of args ] 8 [ argv[0] (pointer) ] 8 (program name) [ argv[1] (pointer) ] 8 [ argv[..] (pointer) ] 8 * x [ argv[n - 1] (pointer) ] 8 [ argv[n] (pointer) ] 8 (= NULL) [ argv[0] ] >=0 (program name) [ '\\0' ] 1 [ argv[..] ] >=0 [ '\\0' ] 1 [ argv[n - 1] ] >=0 [ '\\0' ] 1 ------------------------------------------------------------------------ 注意从上到下是地址从低到高，而用户栈向低地址扩展。栈顶是 argc， 接下来是 argv 数组，它们依次指向每个真正的 argv[i] 字符串。 如果还对 ch7 的命令行参数一节有印象，可能很快就会发现，上面的栈排布和 ch7 指导书教的不太一样。事实上，上面的排布是符合 ELF 文件规范的（见 About ELF Auxiliary Vectors，网页中的 4 在我们这里换成了 8，因为目标架构 riscvgc64 是 64 位），而 rCore-Tutorial 指导书里的写法只能仅供学习参考。 为了支持原生的 Linux 应用，后续最好还是改用这里介绍的写法。 为什么使用这样一个测例项目 为什么我们要绕这么一个大弯，去手写一个测例库呢？你可能会想试试写一个最简单的 hello world： #include int main() { printf(\"hello world\"); } 然后用交叉编译器直接编译后看汇编，其实也没有多少行。但注意，这种方式生成出的可执行程序使用了动态链接，这是一项比赛复赛时才会涉及的功能，目前我们的内核是无法运行这样的程序的。例如在这段汇编中甚至无法找到一个 ecall，这不是说这个用户程序不会执行 syscall，而只是它跳转到了外部的共享库中执行。如果感兴趣，可以在搜索引擎搜索“动态链接”简单了解。 当然也可以指定静态编译。假设上面的 hello world 是 a.c，使用 riscv64-linux-musl-gcc a.c -static 即可。这样得到的可执行文件不依赖外部库了，但有超过 5000 行，很难调试。你也可以在目前的内核中尝试运行它，看看是否会报错。 总之，使用标准库函数（如 printf ）的 C 用户程序不是这次实验要处理的问题。这就是为什么我们手写了一个测例库用于实验。 调试技巧：使用用户态 qemu 进行对拍 测例库里编译的测例都是完全符合规范的 RISC-V 可执行程序，所以它当然可以在其他内核上运行。 如果你还记得，在 rCore-Tutorial的 ch0配环境的时候，安装了 qemu-riscv64 和 qemu-system-riscv64。后者用于运行实验，而前者实际上是一个用户态模拟器。换而言之，它可以直接运行用户态的 RISC-V 程序，我们可以直接把测例文件扔给它。 例如在 testcases/ 目录下执行 qemu-riscv64 ./build/hello，就可以获取正确输出（可以打开 testcases/src/hello.c 看看正确输出长什么样）。 同样地，也可以执行 qemu-riscv64 ./build/42。这个用户程序在退出时返回了一个 42，不过没有打印输出。但我们可以在上面的命令之后立即执行 echo $? 就可以看到返回值 42 $? 是一个shell的变量，表示上一条命令的返回值。 在这个例子中，具体来说是 qemu 的返回值。它执行了我们要求的用户程序，然后把用户程序的返回值作为自己的返回值，推给宿主机。 如此一来，后续我们每次遇到一个新的应用程序，就可以用 qemu-riscv64 进行检查，看看正常的“内核”运行它应该是什么样的，然后来推测我们的内核运行同一个测例时出了什么错。 我们把这种调试方式叫做“对拍”。 "},"docs/lab1/tofs.html":{"url":"docs/lab1/tofs.html","title":"打包进文件系统","keywords":"","body":"打包进文件系统 现在我们已经可以统一 Rust 和 C 的测例了，但现在的 rCore-Tutorial 只支持自动编译 并打包/user 下的测例，怎么把其他测例也放进 easy-fs 呢？ graph LR; /user里的Rust用户程序--编译-->ELF文件 其他用户程序--编译-->ELF文件 ELF文件--/user下的测例自动打包--->easy-fs ELF文件-.如何放进其他测例?.->easy-fs 在 ch6 中，我们知道 easy-fs-fuse 模块负责将用户程序打包成满足 easy-fs 格式的文件系统镜像。既然上面已经分析出 C 的应用和 Rust 的应用赛道文件系统镜像里没什么两样，现在我们就可以扩展这个模块，使得它可以生成同时包含 Rust 和 C 用户程序的镜像。（下面的说明只是其中一种做法，你可以用自己的方式完成这一步！） 其实，如果想要让内核支持 C 应用程序，可以一步到位，直接撇开原本的 user 库，只编译 C 的程序（比赛初赛的测例就完全没有 Rust 的用户程序）。 但由于本来的 rCore-Tutorial 实验已经包含了带 initproc 和 user_shell 的 Rust 用户程序，直接抛弃这些支持就会让调试过程重回 ch3/ch4 的状态，并且也难以利用已通过的大量 rCore 测例检查有没有改错东西，这对基础弱的同学不太友好。 因此，我们选择了折衷的方式进行讲解，让本实验中的内核可同时接收 C 和 Rust 的用户程序。 首先，我们来找找 easy-fs-fuse 是什么时候被调用的。 当在 os 文件夹下运行 make run时，文件系统镜像会自动生成。观察 os/Makefile文件，可以发现 run 命令依赖于 build，build 命令依赖于 fs-img，这就是我们要找的命令了。 fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @rm -f $(FS_IMG) @cd ../easy-fs-fuse && cargo run --release -- -s ../user/src/bin/ -t ../user/target/riscv64gc-unknown-none-elf/release/ 回顾 ch6，最后这条命令的逻辑是，从 -s 后的目录 ../user/src/bin 中获取所有测例的名字，然后在 -t 后的目录 ../user/target/riscv64gc-unknown-none-elf/release/ 中依次找到对应的 ELF 文件，加入到文件系统镜像中。文件系统镜像最终会被放在 -t 后的目录（见 os/Makefile 开头 FS_IMG 的定义）。 这个 -s 有点啰嗦，我们只需要知道什么文件应该被打包，不需要知道它们的源文件是什么，况且之后要支持的 C 用户程序是不会有 Rust 的源文件的。由此可以修改一下这里 -s 和 -t 的语义： -s 之后的目录定义为要打包塞进文件系统镜像中的目录。 easy-fs-fuse 会依次寻找目录中的文件塞进文件系统镜像里。 -t之后的目录仅用来存放最终生成的文件系统镜像。 然后把命令重写成： FS_IMG := target/fs.img ...... fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @rm -f $(FS_IMG) @cd ../easy-fs-fuse && cargo run --release -- -s ../user/build/elf/ -t ../os/target/ 其中 FS_IMG 是 os/Makefile 开头定义的变量。按照新的语义，此时 fs-img 命令的逻辑就变成了“将 ../user/build/elf” 中的所有文件打包成文件系统镜像，放在 ../os/target/ 里。当然，还需要修改 easy-fs-fuse 使之满足新的语义： // easy-fs-fuse/src/main.rs let root_inode = Arc::new(EasyFileSystem::root_inode(&efs)); /* let apps: Vec = read_dir(src_path) .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); for app in apps { // load app data from host file system let mut host_file = File::open(format!(\"{}{}\", target_path, app)).unwrap(); let mut all_data: Vec = Vec::new(); host_file.read_to_end(&mut all_data).unwrap(); // create a file in easy-fs let inode = root_inode.create(app.as_str()).unwrap(); // write data to easy-fs inode.write_at(0, all_data.as_slice()); } */ for dir_entry in read_dir(src_path).unwrap().into_iter() { let dir_entry = dir_entry.unwrap(); let path = dir_entry.path(); let file_name = dir_entry.file_name().into_string().unwrap(); let base_name = &file_name[..file_name.rfind('.').unwrap_or(file_name.len())]; let mut host_file = File::open(&path).unwrap(); let mut all_data: Vec = Vec::new(); host_file.read_to_end(&mut all_data).unwrap(); // create a file in easy-fs let inode = root_inode.create(base_name).unwrap(); // write data to easy-fs inode.write_at(0, all_data.as_slice()); } 对比原本的代码（上面的注释）和修改后的新代码： src_path 目录原本被用来寻找所有源代码文件的名字，生成 apps 后再从 target_path中找对应的文件；修改后，代码通过 read_dir(src_path).unwrap().into_iter() 直接从 src_path 中去寻找文件塞进文件系统镜像里。 原本的代码中，通过 name_with_ext.find('.').unwrap() 找到每一个文件的后缀名，然后通过 name_with_ext.drain 删除，如果文件名中不包含 .，整个 easy-fs-fuse 就会报错。现在的代码通过 file_name.rfind('.') 寻找最后一个后缀名并删除，如果文件名中不包含 .，则会取文件全名。 当然，在现在的实现中，如果出现两个文件仅有后缀名不同的情况，会导致出错，不过这种检查也很容易实现。 可不可以不去除后缀名，直接原封不动把文件放到镜像里？ 可以，但比较麻烦。我们之所以一定要执着地去除后缀名，是因为可执行程序一般默认是无后缀的。如内核启动时首先会去找 initproc，这个用户程序又会去找 user_shell，而每一章的 usertest 也会去找每一个对应章节的测例。如果所有这些地方都考虑后缀，代码改起来就会很麻烦。不过，过渡到只是用 C 语言用户程序的初赛时，可以考虑把去后缀这一步删掉。 还可以把这段修改下面的几行代码 for app in root_inode.ls() { println!(\"{}\", app); } 前的注释删掉以便观察最终被打包的文件有哪些。现在我们回到 os 目录，执行 fs-img CHAPTER=8 BASE=2 可以看到我们修改过的 easy-fs-fuse 正确打包了文件。 如何将 C 语言测例也包括进来呢？ 别忘了 C 的用户程序在 testcases里。我们像 user 那样也调用一次 make build 生成可执行文件，然后把两拨测例复制到一起，再交给 easy-fs-fuse 打包就可以了。现在我们再次修改 os/Makefile 中的 fs-img 命令如下 fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @make -C ../testcases build @rm -f $(FS_IMG) @cp ../user/build/elf/* ../testcases/build/ @cd ../easy-fs-fuse && cargo run --release -- -s ../testcases/build/ -t ../os/target/ 现在我们可以同时打包 Rust 和 C 的用户程序了！ 再次在os 目录执行 fs-img CHAPTER=8 BASE=2，就可以唤出 usershell 了，现在你可以尝试运行本实验所使用的两个 C 语言用户程序了。 "},"docs/lab1/exercise.html":{"url":"docs/lab1/exercise.html","title":"练习","keywords":"","body":"练习 编程作业 完成 rCore-Tutorial 的同学可以从 ch8 开始修改。如果没有做到 ch8，也可以用全新的 ch7 来做实验。 在本实验中，你需要： 跟随前面文档的指引，扩展 easy-fs-fuse，使得它可以生成同时包含 Rust 和 C 用户程序的镜像 在 usershell 里运行了 42 和 hello 两个用户程序。42 的运行结果是符合预期的，但 hello 的结果看起来不太对，你的任务是修改内核，使得 hello 测例给出正常输出（即给出一行以 my name is 开头的输出，且 exit_code为0）。 问答作业 elf 文件和 bin 文件有什么区别？ Linux 的 file 命令可以检查文件的类型，尝试执行以下命令，描述看到的现象，然后尝试解释输出 # 在 user/build/elf/ 下 file ch6_file0.elf # 在 user/build/bin/ 下 file ch6_file0.bin riscv64-linux-musl-objdump -ld ch6_file0.bin > debug.S 如果对应目录下没有文件，请在 user/ 目录执行 make build CHAPTER=8 BASE=2 报告要求 完成编程作业，描述实现思路以及修改的代码。本章没有自动评测，我们会人工检查你的代码实现和报告。 完成问答题。 推荐使用 markdown 格式 和 rCore-Tutorial 实验类似，报告放在 reports/文件夹下，但命名为 labr1.md或labr1.pdf "},"docs/lab2/intro.html":{"url":"docs/lab2/intro.html","title":"实验概述","keywords":"","body":"运行带标准库的 C 程序 建议至少做完本指导书的 lab1 再做这个实验。 实验需要使用你在 rCore-Tutorial 实验中的仓库，但不依赖于你在 rCore-Tutorial 中完成的任何作业代码。你可以用自己的 rCore-Tutorial ch8 分支来做这个实验中的代码修改，也可以用没有修改过的 ch7 分支。 实验准备 从这里获取本次实验需要使用的用户程序。你需要把 lab2 分支下的 testcases 目录放到当前实验（也就是 2023a-rcore- 开头的这个项目）的根目录下，在 testcases 目录下运行 make build 即可在 testcases/build/ 下获得 42 hello hellostd 三个二进制文件。 本次实验中我们只使用 hellostd 这个测例。 实验概述 在上一个实验的为什么使用这样一个测例项目 这一小节中，我们尝试直接交叉编译一个 hello world： #include int main() { printf(\"hello world\"); } 发现内核无法运行这个程序，并且反汇编的结果太长，似乎完全无法调试。 在这次实验中，我们会一步步尝试分析这个测例的报错情况，继续修改内核，使得内核可以成功运行一个带标准库的 hello world。 这一章的文档可能在某种程度上更像一个“debug 记录”。指导书里会把难处理的地方都讲一遍，最后留一个比较简单的小实验作为作业。你可以直接跳到最后一节去完成实验内容，但我们更希望大家可以跟着指导书走一遍调试过程，学习途中的调试思路。 在实验中你可以学到： 若干种常用调试方法：全局搜素、LOG输出、反汇编、GDB调试 如何引入其他内核的代码来完成实验 阅读标准 Linux syscall 规范，并按照它实现 syscall 的方法 rCore-Tutorial 和 Linux syscall 规范的区别 在实验之后 你可以以本实验为基础，完成比赛决赛第一阶段要求的 libc-test，测例见这里。这个测例集分两个部分，分别是静态链接的测例（gcc 编译加 -static选项）和动态链接的测例。 支持 libc-test 中的静态链接测例 支持静态链接测例的思路和实验类似。但所有测例本身都会用到 runtest.exe，它的源代码中包含了许多复杂的 syscall。 你可以使用本实验中的分析方法想办法跳过它们，也可以尝试使用这里提到的思路，逐个击破一些小测例，最后再使用 runtest.exe 运行。 支持 libc-test 中的动态链接测例 支持动态链接测例时，需要内核在ELF加载器中主动添入GOT表和PLT表项。如果觉得太难，也可以直接参考从往届代码的实现，比如本实验引用的这个内核 就在 kernel/src/loaders/mod.rs 模块中带了动态链接的实现。 "},"docs/lab2/pos.html":{"url":"docs/lab2/pos.html","title":"三种调试方法","keywords":"","body":"寻找报错位置 在这一小节中，我们会尝试分析 hellostd 测例的报错情况，并介绍三种常见的内核调试技巧。巧合的是，我们的调试过程恰好会用到每一项技巧，因此你可以跟着指导书走一遍整个流程以熟悉它们，而不只是枯燥地听课看文档。 调试技巧：全局搜索输出 按照上一节的实验准备下载好测例后，我们来尝试在目前的内核中运行 hellostd 这个测例。在 os/ 目录下 make run，然后在弹出的终端中输入 hellostd，大概率会得到下面这样一行错误输出： Rust user shell >> hellostd Shell: Process 2 exited with code -11 如果运行结果是 exited with code -4 而不是 -11，说明你在上一个实验中的实现碰巧“跳过”了这一个 bug。此时可以阅览一下本节的内容，然后下一节再跟着做 显然，这个测例运行失败了，但是是在哪里失败的呢？我们可以尝试全局搜索一下这一行是在哪里输出的。首先，2 和 -11 看上去不像是直接写在代码里的内容，我们要找的应该是 Shell: Process 和 exited with code 这两段文本，且它们中间隔着一些其他字符。所以可以把要搜索的表达式写成 Shell: Process .* exited with code 注意，不要想当然认为中间要搜的部分是 [0-9] 的数字。它们应该是任意匹配的字符。 因为要搜索的是“代码”而不是同样格式的“输出”，所以很可能我们要找的内容类似下面几种形式之一： println!(\"Shell: Process {} exited with code {}\", id, code); println!(\"Shell: Process {id} exited with code {code}\"); printf(\"Shell: Process %d exited with code %d\", id, code); 它们中间对应 2 和 -11 的部分都不是数字。 然后我们就可以使用如下命令搜索可能的输出位置。 grep -rn \"Shell: Process .* exited with code\" ./src 其中，-r 表示递归搜索下面的目录，-n 表示找到字符串时输出对应行号。而 ./src 是我们要搜索的目录，因为现在在 os/ 下，所以实际搜索的是 os/src/ 下的内容，也就是内核的代码。 不出意外的话，上面这条命令不会给出任何输出，这说明内核代码里没有这样的语句。不过，这一行也可能是用户程序输出的，我们在用户测例的代码目录再试一次： grep -rn \"Shell: Process .* exited with code\" ../user/src 这次我们找到了输出的具体位置，是其中一个 user_shell，即终端程序。具体是哪一个取决于你正在运行本实验的分支。 ../user/src/bin/ch8b_user_shell.rs:193: //println!(\"Shell: Process {} exited with code {}\", pid, exit_code); ../user/src/bin/ch7b_user_shell.rs:107: println!(\"Shell: Process {} exited with code {}\", pid, exit_code); ../user/src/bin/ch6b_user_shell.rs:43: println!(\"Shell: Process {} exited with code {}\", pid, exit_code); ../user/src/bin/ch5b_user_shell.rs:43: println!(\"Shell: Process {} exited with code {}\", pid, exit_code); VSCODE 的全局搜索 如果你在使用带 GUI 的 IDE 编程，也可以完全不用记上面的命令。例如 VSCODE 就带有一个搜索器。 以 VSCODE 为例，简单介绍一下这个工具的用法： 如图所示，你可以在窗口左侧找到搜索功能（标点1），然后在第一个框内输入要搜索的字符串。 如果字符串中包含正则匹配相关的内容，可以打开右侧的正则表达式开关（标点2）。顺便一提，前两个开关分别是区分大小写和全词匹配（即不允许匹配半个词，两边必须是空格或符号） 这个搜索的范围默认是这个窗口打开的目录。如果想在指定目录下搜索，或者去除某些目录的搜索结果，可以点开右下角的按钮（标点3），然后输出搜索目录。 你可以直接点击搜索结果跳转到对应的文件，不需要手动翻找目录去打开文件。 调试技巧：别忘了 LOG 输出 找到了输出位置，我们来看看 user_shell 为什么会告诉我们 Shell: Process 2 exited with code -11。先阅览一下 ch7b_user_shell.rs 在这条输出附近的代码： if pid == 0 { // input redirection if !input.is_empty() { let input_fd = open(input.as_str(), OpenFlags::RDONLY); if input_fd == -1 { println!(\"Error when opening file {}\", input); return -4; } let input_fd = input_fd as usize; close(0); assert_eq!(dup(input_fd), 0); close(input_fd); } // output redirection if !output.is_empty() { let output_fd = open(output.as_str(), OpenFlags::CREATE | OpenFlags::WRONLY); if output_fd == -1 { println!(\"Error when opening file {}\", output); return -4; } let output_fd = output_fd as usize; close(1); assert_eq!(dup(output_fd), 1); close(output_fd); } // child process if exec(args_copy[0].as_str(), args_addr.as_slice()) == -1 { println!(\"Error when executing!\"); return -4; } unreachable!(); } else { let mut exit_code: i32 = 0; let exit_pid = waitpid(pid as usize, &mut exit_code); assert_eq!(pid, exit_pid); println!(\"Shell: Process {} exited with code {}\", pid, exit_code); } 可以看到，这个程序执行失败并不是因为打开文件失败或者 exec 函数失败，而是 user_shell 在 waitpid 等待它执行完成的时候，得知了程序返回 -11 的消息。这说明它很可能已经正常进入用户态了，是运行途中出现的问题。 那么，-11 是哪来的呢？如果是用户程序自己 exit 时传入的参数 -11，那么我们可能得另找办法了。不过幸运的是，我们直接在内核代码中搜索 -11 就能找到它的来源： grep -rn \"\\-11\" ./src ./src/task/context.rs:11: /// s0-11 register, callee saved ./src/task/signal.rs:33: Some((-11, \"Segmentation Fault, SIGSEGV=11\")) 如果不加反斜杠 \\，grep 会把 - 理解成正则表达式里的负号。而加了反斜杠以后， \\- 才表示我们真的想搜索这个负号。你可以试一试去掉反斜杠 \\ 会搜出什么结果。 所以有搜索 GUI 的情况下还是用 GUI 比较方便。 来自 signal.rs 的代码告诉我们，-11 可能来自一个段错误，继续搜索 SIGSEGV 就能找到触发的位置： /// at os/src/trap/mod.rs #[no_mangle] pub fn trap_handler() -> ! { set_kernel_trap_entry(); let scause = scause::read(); let stval = stval::read(); // trace!(\"into {:?}\", scause.cause()); match scause.cause() { Trap::Exception(Exception::UserEnvCall) => { // jump to next instruction anyway let mut cx = current_trap_cx(); cx.sepc += 4; // get system call return value let result = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12], cx.x[13]]); // cx is changed during sys_exec, so we have to call it again cx = current_trap_cx(); cx.x[10] = result as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) | Trap::Exception(Exception::InstructionFault) | Trap::Exception(Exception::InstructionPageFault) | Trap::Exception(Exception::LoadFault) | Trap::Exception(Exception::LoadPageFault) => { error!( \"[kernel] trap_handler: {:?} in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", scause.cause(), stval, current_trap_cx().sepc, ); current_add_signal(SignalFlags::SIGSEGV); } 这个测例是不是触发了 Exception::LoadPageFault？注意到 SISEGV 前有 error 输出，我们只需要使用 make run LOG=ERROR 就可以看到所有 ERROR 级别以上的内核输出了。其实在 rCore-Tutorial ch3 的问答作业中就提到过 LOG 功能的用法，甚至于在 ch1 和 ch2 中还尝试了使用 log 输出五颜六色的调试语句，不过可能大部分同学已经忘了还有这一层调试工具。 现在我们在 os/ 目录下执行 make run LOG=ERROR，然后在弹出的终端中输入 hellostd，你会得到如下所示的输出 >> hellostd [ERROR] [kernel] trap_handler: Exception(LoadPageFault) in application, bad addr = 0xb000, bad instruction = 0x572, kernel killed it. Shell: Process 2 exited with code -11 虽然报错的地址可能略有不同（取决于你在上一个实验中的代码实现），但我们终于可以确认，测例 hellostd 运行失败就是由于触发 LoadPageFault 访问了错误的地址。 LOG 输出的注意事项 总的来说，我们建议在每次出 bug 时首先打开 LOG 输出再运行，也就是 make run LOG=ERROR 或者更低的 LOG 等级，比如 make run LOG=TRACE。但使用 LOG 也会有一些需要注意的地方： LOG 只会输出我们预先埋在代码中的 error! warn! trace! 等等这些语句，换句话说，它只能检查到我们预期可能会出 bug 的点。但问题也可能出现在我们没有预料到的地方，所以调试过程中很可能还需要新加 LOG 语句。 在运行特定测例时，一些代码执行的频率过高，在其中插入 LOG 语句时要再三考虑。比如 user_shell 中每输出一个字符就会调用一次 sys_read，再比如有些应用会反复调用 sys_clock_get_time 来更新自身的时间，如果在这些地方插入 LOG，输出屏幕很快就会被大量的调试输出淹没。 LOG 自己也可能导致报错！ 最常见的情况是，LOG 或者 println! 尝试输出一个拥有无效地址的变量。当我们查到某个变量 x 的值可能不对，想用 LOG 输出时，输出语句本身可能会触发 LoadPageFault。通常来说，这是因为内核从用户程序拿到了一个指针(比如 *const u8)，然后没有检查这个指针所指的地址是否无效，就把它类型转换成了变量。此时可以用 :p 来输出它的地址，例如 error!(\"{:p}\", &x)。 另一种常见的情况是，添加或者删除 LOG 语句影响了运行测例的结果。这通常是由于内核栈溢出导致的，下次遇到“加了 print结果居然变了”的情况请先检查堆栈是否够用。 调试技巧：反汇编 上面的报错信息告诉我们，用户程序在 0x572 访问了一个地址 0xb000，而这个用户对这个地址没有读取权限（事实上这一页在用户页表中没有映射，如果不记得页表机制可以回去看 rCore-Tutorial ch4）。我们可以用上一个实验中检查可执行文件内容的方法，去看看 hellostd 里 0x572 这个位置到底是什么。我们在 testcases/ 目录下执行 riscv64-linux-musl-objdump build/hellostd -ld > hellostd.S build/hellostd: file format elf64-littleriscv Disassembly of section .text: 0000000000000508 : exit(): 508: 1101 addi sp,sp,-32 50a: e42a sd a0,8(sp) 50c: ec06 sd ra,24(sp) 50e: 436000ef jal ra,944 512: 434000ef jal ra,946 516: 00007317 auipc t1,0x7 51a: c6233303 ld t1,-926(t1) # 7178 51e: 9302 jalr t1 520: 6522 ld a0,8(sp) 522: 523010ef jal ra,2244 0000000000000526 : _start(): 526: 00007197 auipc gp,0x7 52a: 2da18193 addi gp,gp,730 # 7800 52e: 850a mv a0,sp 530: 00007597 auipc a1,0x7 534: 96058593 addi a1,a1,-1696 # 6e90 538: ff017113 andi sp,sp,-16 53c: a015 j 560 000000000000053e : __dls2(): 53e: 00858613 addi a2,a1,8 542: 418c lw a1,0(a1) 544: 4781 li a5,0 546: 00007717 auipc a4,0x7 54a: c4273703 ld a4,-958(a4) # 7188 54e: 00007697 auipc a3,0x7 552: bf26b683 ld a3,-1038(a3) # 7140 556: 00007517 auipc a0,0x7 55a: c1a53503 ld a0,-998(a0) # 7170 55e: ae4d j 910 0000000000000560 : _start_c(): 560: 6118 ld a4,0(a0) 562: df010113 addi sp,sp,-528 566: 862a mv a2,a0 568: 2705 addiw a4,a4,1 56a: 00371793 slli a5,a4,0x3 56e: 00f606b3 add a3,a2,a5 572: 6694 ld a3,8(a3) 574: 0705 addi a4,a4,1 576: faf5 bnez a3,56a 用上面的代码对比我们在上一个实验中看到的 Rust 测例的反汇编以及目前内核可以运行的 42 hello 两个测例的反汇编，再结合报错时尝试访问的 0xb000 是用户栈顶，可以猜到 0x572 的位置大概是在用户栈上读取信息但读“越界”了。这说明我们的用户栈实现可能还有问题。 是的，我们刻意模糊了这一段发现问题的过程！ 有时我们可以从反汇编代码中看出问题所在，但这并不总是行得通。在这个例子中，“用户栈有问题”就是一个“知识鸿沟”，很难直接用 debug 技巧解决。实际开发可能需要大量查阅资料、询问他人、翻找往届能通过测例的内核代码，才能知道具体出错的原因。所以这一次我们就直接假设跳过了查询的过程，直接看如何解决这个bug。 "},"docs/lab2/usecode.html":{"url":"docs/lab2/usecode.html","title":"引入外部代码","keywords":"","body":"引入外部代码 我们希望修改用户栈的实现，以满足标准库的需求。具体来说，用户栈需要满足上一章中提到的 ELF 文件规范： position content size (bytes) + comment ------------------------------------------------------------------------ stack pointer -> [ argc = number of args ] 8 [ argv[0] (pointer) ] 8 (program name) [ argv[1] (pointer) ] 8 [ argv[..] (pointer) ] 8 * x [ argv[n - 1] (pointer) ] 8 [ argv[n] (pointer) ] 8 (= NULL) [ envp[0] (pointer) ] 8 [ envp[1] (pointer) ] 8 [ envp[..] (pointer) ] 8 [ envp[term] (pointer) ] 8 (= NULL) [ auxv[0] (Elf32_auxv_t) ] 16 [ auxv[1] (Elf32_auxv_t) ] 16 [ auxv[..] (Elf32_auxv_t) ] 16 [ auxv[term] (Elf32_auxv_t) ] 16 (= AT_NULL vector) [ padding ] 0 - 16 [ argument ASCIIZ strings ] >= 0 [ environment ASCIIZ str. ] >= 0 (0xbffffffc) [ end marker ] 8 (= NULL) (0xc0000000) 0 (virtual) ------------------------------------------------------------------------ 注意因为目标架构 riscvgc64 是 64 位，所以网页中的 4 在我们这里换成了 8，而 8 换成了 16。 你当然可以手动实现上面的内容，但我们想趁机向你介绍如何引入其他内核的实现来完成这个任务。 找到对应模块 一般来说，每一届操作系统比赛都会沿用往年的测例，然后添加新测例，因此这些通用的功能很可能就是往届内核里造过的“轮子”，而参考这些内核的实现将会是绝大部分同学不得不经历的过程。比赛本身并不排斥大家用往年的实现，只要在文档里说明来源即可。 那么这又引出另一个问题，参加比赛能不能直接沿用往届的完整内核来开发呢？当然可以！ 事实上，下一章的实验就是基于一个往届的内核来做的。不过，往年内核的功能不能算是你在本届比赛中的贡献，而别人的代码总是会比自己的代码难理解许多，所以单纯想一口吃成胖子只会让后续的开发举步维艰。 我们需要实现的模块在大部分内核中被叫做 ELF Loader，因为初始化用户栈、生成环境变量等信息发生在“用户程序加载进内核”的过程中。你可以在比赛页面查询往年内核实现赛的获奖名单，然后在 github 或者 官方 gitlab 上搜索对应的内核项目。在本次实验中，我们用这个内核的 kernel/src/loaders 模块。 我们开发的是 Rust 内核，所以最好的情况当然是直接使用包装成 Rust Crate 的模块，这样我们只需要在 os/Cargo.toml 里引入模块作为依赖，就可以在内核中使用它了。不过就目前来说，操作系统比赛的内核实现中的大部分还没有这么高的模块化，只能使用复制粘贴代码的方式来“复用模块”。但模块化是本指导书的目标之一，在后续实验中我们会实现一个独立于内核的 Rust Crate，它支持某项特定的内核功能。 修改模块以适配内核 在测例仓库的 lab2 分支的 loaders 子目录下有已经修改好的模块，可以按照测例仓库 README.md 中提到的方法，把它直接放进你的 os/src 下。 本节剩下的内容只是在展示和解释我们修改原始模块的过程，以便你学习如何为内核添加其他模块。你当然可以用另一种方式精简这个模块或者使用其他模块。 允许新模块的 warning 以及缺失文档问题 首先，我们复制这个文件夹的内容到 rCore-Tutorial 的 os/src 目录下，然后在 os/src/main.rs 中引入这一模块（添加一条 pub mod loaders），尝试直接运行 make run。不出意外地它报错了，其中一类错误如下： error: unused import: `sections::SectionData` --> src/loaders/mod.rs:19:5 | 19 | sections::SectionData, | ^^^^^^^^^^^^^^^^^^^^^ | note: the lint level is defined here --> src/main.rs:22:9 | 22 | #![deny(warnings)] | ^^^^^^^^ = note: `#[deny(unused_imports)]` implied by `#[deny(warnings)]` 报错信息指出，其中有一些变量没有被使用到。为什么这样的情况不是 warning 而是 error 呢？因为 main.rs 在开头特地指明了 #![deny(missing_docs)] 和 #![deny(warnings)]，表示所有缺失文档的文件、类、函数乃至所有 warning 都不被允许。这是一个非常好的特性，可以有效改善代码质量，但在调试时我们可以针对对应模块暂时取消它： // at os/src/main.rs #[allow(missing_docs)] #[allow(warnings)] pub mod loaders; 删掉不需要的功能和所有不存在的引用 看一下这个模块里的代码，发现它其实做了等同于 rCore-Tutorial 内核中 os/src/mm/memory_set.rs:MemorySet::from_elf() 的事情，也就是解析 ELF 文件的每一个 LOAD 段并塞入用户页表中。但我们只想要它处理用户栈的部分，也即： let info = InitInfo { ...... }; info!(\"info {:#?}\", info); let init_stack = info.serialize(stack_top); debug!(\"init user proc: stack len {}\", init_stack.len()); stack_pma.write(USER_STACK_SIZE - init_stack.len(), &init_stack)?; stack_top -= init_stack.len(); 这一部分，所以我们可以把 init_vm 函数里的其他部分删掉（除了获取 elf_base_vaddr 变量的一段，因为这个变量会被 info = InitInfo {... } 用到）。其他用不到的函数和类也可以删掉，只留下 ElfLoader 里的 new 和 init_vm。然后把每个文件开头用不到的引用以及不存在的模块引用删掉，它们并不属于我们的 rCore-Tutorial 内核。 替换原代码中的函数参数、返回值、常量 接下来就需要分门别类分析各个报错的位置了。举三个例子： ElfLoader::new 函数的返回值 OSResult 这个类不存在，但看函数实现可以发现它其实是想返回 ElfLoader 这个类本身或者返回一个报错字符串。所以我们直接将返回类型改为 Result，错误消失了。 ElfLoader::init_vm 的参数中，有一个 vm: &mut MemorySet,。MemorySet 看起来和我们内核中的 MemorySet 是类似的，但通过 vm: &mut MemorySet 输入会报错。回顾 os/src/task/process.rs:ProcessControlBlock::exec 函数，我们使用 memory_set 的方式应该是获取一个 usize 类型的 memory_set.token()，所以这里我们把这个参数替换成 memory_token: usize。此外，由于我们的 os/src/mm/memory_set.rs:MemorySet::from_elf() 已经生成了用户栈底地址，所以还要加一个参数 stack_top: usize 代码中用到一些常量，如 PAGE_SIZE USER_STACK_SIZE 可以用我们内核中 os/src/config.rs 中对应的常数代替。如果不清楚常数的含义，可以选择去查这个模块来源的内核。 总之，我们将替换原代码中的函数参数、返回值、常量，改成自己内核中对应的值 必要时增写函数或者功能 最后，我们还需要处理代码中用到但我们目前内核中没有的功能。通过查模块来源的内核的注释（或者通过上一节教的全局搜索）可以得知，原代码中的 stack_pma.write(USER_STACK_SIZE - init_stack.len(), &init_stack)?; 一行是将 init_stack 里的内容全部写到用户栈上。我们的内核没有这么方便的函数，但有一个类似的 translated_byte_buffer，可以利用它把原代码的这一行改写成： let stack = translated_byte_buffer(memory_token, stack_top as *const u8, init_stack.len()); // 接下来要把 init_stack 复制到 stack 上 let mut pos = 0; for page in stack { let len = page.len(); page.copy_from_slice(&init_stack[pos..pos + len]); pos += len; } assert!(pos == init_stack.len()); 之后，把模块前的 #[allow(missing_docs)] 和#[allow(warnings)] 删掉，就几乎得到在测例仓库的 lab2 分支的 loaders 子目录的模块了。 部分同学可能会有疑问：info = InitInfo {... } 里定义的 auxv 以及用到的 elf_base_vaddr 事实上也都是没用的，全删掉也不影响运行，为什么测例仓库给出的模块没有处理它们？ 这是因为我们在添加一个新模块时，很难准确判断哪些东西是不必要的。在本实验中我们要用“用户栈的预处理”这一部分，其他的可以删除，但并不知道这一部分之中哪些是必要的。在这种情况下，尽可能保留原有模块的部分在某种程度上可以提高运行成功的概率。等到我们成功运行这个模块之后，可以再来考虑删掉哪些部分。 事实上，在比赛决赛第一阶段的 libc-test 测例中，需要使用到原 loaders 模块的所有内容，所以所有删掉的代码最后都是要加回来的。 "},"docs/lab2/gdb.html":{"url":"docs/lab2/gdb.html","title":"GDB 调试","keywords":"","body":"GDB 调试 在引入 loaders 模块后，我们仍然没有跑通 hellostd，这次的运行结果是 >> hellostd Shell: Process 2 exited with code -4 回顾我们第一次运行这个测例时的输出，可以发现仍然是 user_shell 的同一个位置报错（虽然 user_shell 的其他地方会 return -4，但哪些位置的错误输出都是以 Error when 开头，和我们看到的输出不符）。也就是说，这个程序执行失败是在 user_shell 在 waitpid 等待它执行完成的时候，得知了程序返回 -4 的消息。 继续依葫芦画瓢，在 os/src 中搜索 -4，可以找到 src/task/signal.rs 中的 Some((-4, \"Illegal Instruction, SIGILL=4\"))。问题是类似的，但这次我们没有看到 ERROR 输出。这是因为 rCore-Tutorial 实验框架忘记在 os/src/trap/mod.rs:trap_handler 的 IllegalInstruction 一项里加错误输出了，我们给它补上： ...... Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) | Trap::Exception(Exception::InstructionFault) | Trap::Exception(Exception::InstructionPageFault) | Trap::Exception(Exception::LoadFault) | Trap::Exception(Exception::LoadPageFault) => { error!( \"[kernel] trap_handler: {:?} in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", scause.cause(), stval, current_trap_cx().sepc, ); current_add_signal(SignalFlags::SIGSEGV); } Trap::Exception(Exception::IllegalInstruction) => { error!( \"[kernel] trap_handler: {:?} in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", scause.cause(), stval, current_trap_cx().sepc, ); current_add_signal(SignalFlags::SIGILL); } Trap::Interrupt(Interrupt::SupervisorTimer) => { set_next_trigger(); check_timer(); suspend_current_and_run_next(); } ...... 再次运行，我们看到了这样的输出 >> hellostd [ERROR] [kernel] trap_handler: Exception(IllegalInstruction) in application, bad addr = 0x464c457f, bad instruction = 0x0, kernel killed it. Shell: Process 2 exited with code -4 这次的情况略有不同。出错的指令地址是 0x0，也就是说，用户程序尝试在 0x0 执行一条指令。显然，问题不在于 0x0 有什么，而在于用户程序是怎么跑到那里去的。我们用 gdb 来实时跟踪用户程序的执行过程。 精简 gdb 命令 一千个人有一千种方式使用 gdb，我们在此仅介绍最基本的一种。你可能会需要下面这些命令： b *0x12345678 表示在 0x12345678 这个地址设置断点 i 可以查看各种信息。例如 i b 是查看断点，i reg 是查看所有通用寄存器 d 1 可以删除 1 号断点。先用 i b查看断点编号再删除 x/10i $pc 表示输出从 pc 当前位置开始往下的十条指令。pc 可以换成其他地址 si 表示向下执行一条指令 n 可以执行下一行代码，不进入本行执行的函数。对用户程序不一定有效 c 表示继续运行，直到遇到下一个断点为止 ctrl+C 可以打断运行，如果一次 c 执行太久没有相应可以试试这个 q 可以退出 gdb 内核中运行 gdb 的注意事项 上面给出的命令中没有跟查看源代码或者函数符号相关的命令，这是因为 gdb 本质上是在对内核运行。而对于内核运行起来后实时加载的用户程序，gdb 无法掌握它们的符号信息，因而只能通过具体的地址进行调试，也只能看到汇编指令。 如果有 gdb 扩展或者其他项目支持查看内核中加载的用户程序的符号，可以联系我们，后续加进教程里 不过，查看内核的源代码是可以的。在 os/Makefile 下把第 2 行的 MODE := release 改为 MODE := debug 就可以了。 gdb 也不支持跨地址空间的查找。换句话说，它只知道当前能不能访问某个地址（虚拟地址），不会管现在的页表在哪，所以内核调试时经常会遇到因为地址当前无法访问而打不上断点的情况。这时可分为以下情况处理： 把断点打在内核入口，也即 0x80200000 处，然后使用 c 命令跳过去。之后就可以打大部分内核符号的断点了。 把断点打在 mm::init() （页表初始化函数）然后使用 c 命令跳过去，再用 n 指令跳过这段流程，就可以打页表中有映射的地址的断点了，例如跳板页 TRAMPOLINE。 一般来说，如果想打用户程序的断点，可以把断点先打在内核的 __alltraps 和 __restore 上，这是在 os/src/trap/trap.S 中定义的从内核到用户程序的入口和异常中断的入口。然后手动执行直到它跳到用户程序的地址，之后就可以打用户地址的断点了。 但 rCore-Tutorial 实际上的 __alltraps 和 __restore 会被复制到跳板页 TRAMPOLINE 去执行。对于 __alltraps，它就是跳板页地址 TRAMPOLINE 对于 __restore，我们可以先 b __restore b __alltraps 查看这两个地址的偏移，然后算出它相对于 TRAMPOLINE 的偏移，从而在跳板页的对应位置打上断点 上面的过程实在比较麻烦，可以有以下几种办法改进 先使用 c 命令，等待程序运行到 user_shell 等待输出的时候，再 ctrl+C，就可以打用户地址空间的断点了。但缺点是此时无法打内核的断点 把上面断点的流程写进 gdb 脚本 把初始化页表放在内核启动的最开头 entry.asm 里，可以省去第二步；使用单页表（见rCore-Tutorial 指导书 ch4 练习）把跳板页去掉，可以直接把断点打在 __alltraps 和 __restore，省去第三步。 使用 rCore-Tutorial 自带的命令调试 在 os/Makefile 的最下面有这些命令 debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d gdbserver: build @qemu-system-riscv64 -M 128m -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) \\ -drive file=$(FS_IMG),if=none,format=raw,id=x0 \\ -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 \\ -s -S gdbclient: @riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234' 下面尝试使用 gdbserver 和 gdbclient 进行调试。 首先打开两个终端，它们都切换到 os/ 这个目录。然后在第一个终端执行 make gdbserver，在第二个终端执行 make gdbclient。如果在第二个终端看到下面的输出，表示连接成功 ❯ make gdbclient GNU gdb (SiFive GDB 9.1.0-2020.08.2) 9.1 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=x86_64-linux-gnu --target=riscv64-unknown-elf\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: . Find the GDB manual and other documentation resources online at: . For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\". Reading symbols from target/riscv64gc-unknown-none-elf/release/os... The target architecture is assumed to be riscv:rv64 Remote debugging using localhost:1234 warning: Architecture rejected target-supplied description 0x0000000000001000 in ?? () (gdb) 先预想一下接下来发生什么事情： initproc 先启动，然后是 user_shell 我们会在 user_shell 里输入 hellostd 这个字符串 之后 os/src/task/process.rs:ProcessControlBlock::exec 会加载 hellostd 这个测例。 等到它运行到用户态时，会报错 由此可以设计出一种断点流程（(gdb)开头的内容都是在 gdb client 那个终端输入的）： (gdb) b ProcessControlBlock::exec (gdb) c // 此时执行到该断点，程序暂停。看一下 gdb server 那个终端，得知是正在启动 user_shell (gdb) c // 此时没有执行到该断点。此时执行到该断点，发现终端已启动 // 切到 gdb server 那个终端输入 hellostd // 此时执行到该断点，程序暂停。hellostd 测例准备启动，下一个断点打到 __restore (gdb) b *0xfffffffffffff060 (gdb) c // 此时执行到该断点，程序暂停。删除 __restore 的断点，因为它在进入用户态后会无法访问 (gdb) d 2 (gdb) si // 按住回车不动，等 gdb 一直往下执行，直到切到用户地址 // 然后对一下反汇编结果，确认当前是否在 hellostd 测例中 (gdb) x/10i $pc (gdb) si // 按住回车不动，等 gdb 一直往下执行，直到切到用户地址，看哪里跳转到0 执行上面的流程，最后会发现是在 0x608 这个地址跳转到 0 的。看一下反汇编这个地址附近的指令： 5fc: a0878793 addi a5,a5,-1528 600: 639c ld a5,0(a5) 602: 85b2 mv a1,a2 604: 21010113 addi sp,sp,528 608: 8782 jr a5 0x608 的一条 jr a5 跳转到了 0x0。这个错误的 a5 是在上面 0x600 的一条 ld a5,0(a5) 加载的。 这时可以按 q 退出 gdb，重新走一遍上面的流程，在最后一步进入 hellostd 的用户态时，加一个断点 b *0x600，就可以 c 跳到这一条加载指令之前。这时通过 i reg 查看通用寄存器的值，可以得知 a5 的值是 0x7000。 那么 0x7000 的位置应该有值吗？如果它不是 0，又应该是多少呢？ 收尾工作 内核里有一个函数会直接操作用户地址空间，就是 os/src/mm/memory_set.rs:MemorySet::from_elf()。自然地我们会想要加一条调试输出检查它加载 ELF 文件时每一段的地址： pub fn from_elf(elf_data: &[u8]) -> (Self, usize, usize) { let mut memory_set = Self::new_bare(); // map trampoline memory_set.map_trampoline(); // map program headers of elf, with U flag let elf = xmas_elf::ElfFile::new(elf_data).unwrap(); let elf_header = elf.header; let magic = elf_header.pt1.magic; assert_eq!(magic, [0x7f, 0x45, 0x4c, 0x46], \"invalid elf!\"); let ph_count = elf_header.pt2.ph_count(); let mut max_end_vpn = VirtPageNum(0); for i in 0..ph_count { let ph = elf.program_header(i).unwrap(); if ph.get_type().unwrap() == xmas_elf::program::Type::Load { let start_va: VirtAddr = (ph.virtual_addr() as usize).into(); let end_va: VirtAddr = ((ph.virtual_addr() + ph.mem_size()) as usize).into(); error!(\"start_va {:x} end_va {:x}\", start_va.0, end_va.0); ...... 再次运行测例，得到输出： >> hellostd [ERROR] start_va 0 end_va 5aac [ERROR] start_va 6e70 end_va 7820 这个结果和其他测例有什么不同吗？可以再试试 hello 42 乃至原本的 Rust 测例比如 ch2b_power_3，发现只有 hellostd 的 start_va 不是页对齐的。 继续看 from_elf 这个函数，会发现在下面这一句 memory_set.push( map_area, Some(&elf.input[ph.offset() as usize..(ph.offset() + ph.file_size()) as usize]), ); 实际上是默认了每一个 LOAD 段都是页对齐的。因为它把来自 ELF 文件的段数据 elf.input 直接塞进 map_area 的区间里，没有做任何偏移。我们终于找到了 bug 的源头。于是我们将这段代码改成考虑偏移的版本： if start_va.page_offset() == 0 { memory_set.push( map_area, Some(&elf.input[ph.offset() as usize..(ph.offset() + ph.file_size()) as usize]), ); } else { let data_len = start_va.page_offset() + ph.file_size() as usize; let mut data: Vec = Vec::with_capacity(data_len); data.resize(data_len, 0); data[start_va.page_offset()..].copy_from_slice(&elf.input[ph.offset() as usize..(ph.offset() + ph.file_size()) as usize]); memory_set.push( map_area, Some(data.as_slice()), ); } 其中 else 分支创建了一个 data Vector，它在页偏移的部分填 0，后面再存来自 elf.input 的真正的数据。 至此，我们终于解决了 Shell: Process 2 exited with code -4 的问题。 "},"docs/lab2/syscall.html":{"url":"docs/lab2/syscall.html","title":"通过 Manual Page 添加 Syscall","keywords":"","body":"通过 Manual Page 添加 Syscall 加上上一章里对 os/src/mm/memory_set.rs:MemorySet::from_elf() 的修改，现在我们再次运行 hellostd 测例。 不出意外的话，输出应该是（根据你原仓库的实现，报错行号可能略有不同）： >> hellostd [kernel] Panicked at src/syscall/mod.rs:168 Unsupported syscall_id: 96 坏消息是，它仍然没有运行成功；好消息是，这实际上已经是最后一步了！只要我们按照 rCore-Tutorial 那样填补上缺失的 syscall，就可以成功运行这个测例。不过，这时候就不是指导书来定义这些 syscall 了，而是需要查看通用的 syscall 标准。 Syscall 定义 通常来说，syscall 定义可以在 man7.org 查到，比如这是一个 sys_clone 的定义，里面包含了你可能需要知道的绝大部分东西，包括 接口定义和参数列表int clone(int (*fn)(void *_Nullable), void *stack, int flags, void *_Nullable arg, ... /* pid_t *_Nullable parent_tid, void *_Nullable tls, pid_t *_Nullable child_tid */ ); syscall 的语义以及各个参数的语义。这包括关于 syscall 本身的描述和各个参数的描述。如果参数包括标志位，还会提每一个标志位的含义。不过这个页面并不会告诉你在哪一个位。下面节选一些 sys_clone 的定义 DESCRIPTION These system calls create a new (\"child\") process, in a manner similar to fork(2). By contrast with fork(2), these system calls provide more precise control over what pieces of execution context are shared between the calling process and the child process. ...... The clone() wrapper function When the child process is created with the clone() wrapper function, it commences execution by calling the function pointed to by the argument fn. (This differs from fork(2), where execution continues in the child from the point of the fork(2) call.) The arg argument is passed as the argument of the function fn. clone3() ...... Equivalence between clone() and clone3() arguments ...... The flags mask CLONE_CHILD_CLEARTID (since Linux 2.5.49) Clear (zero) the child thread ID at the location pointed to by child_tid (clone()) or cl_args.child_tid (clone3()) in child memory when the child exits, and do a wakeup on the futex at that address. The address involved may be changed by the set_tid_address(2) system call. This is used by threading libraries. CLONE_CHILD_SETTID (since Linux 2.5.49) ...... CLONE_CLEAR_SIGHAND (since Linux 5.5) ...... 返回值 错误类型。在 rCore-Tutorial 中，如果一个 syscall 执行失败，通常是直接返回 -1 的。但在 POSIX syscall 中，syscall 可以返回不同的负数，代表不同的错误类型。一些标准库程序会通过判断不同的错误类型来执行不同的代码，所以 debug 时别忘了你给用户程序返回的错误类型也可能出错。 其他需要说明的问题，比如存在的版本冲突、历史版本问题、额外的说明、代码示例等等 一些链接，可以点到相关的其他 syscall 如何搜索到Syscall定义 一般来说，如果你知道 syscall 的名字。总是可以用搜索引擎找到上面的页面的。 但我们现在只知道 syscall 的 ID 是 96，怎么知道它是谁呢？ 可以用网上整理好的博客，比如这一篇，在网页里搜索 96 就能找到我们想要的 sys_set_tid_address。 可以通过源代码查询。例如我们在最初的实验 中下载的交叉编译工具链使用的 musl-libc。可以在这里 下载到 musl 库的源代码，然后在目录下的 arch/riscv64/bits/syscall.h.in 中找到 syscall 对应的名字。 回到主线 至少在参加比赛这个阶段，当我们要实现一个 syscall 时不需要实现定义里的所有内容。定义中 90% 的部分可能只会有不到 1% 的应用程序会使用。因此，我们只希望支持最基本的功能，让用户程序成功运行就行，更详细的定义可以以后需要时再加。 现在我们需要实现 96 号 syscall set_tid_address，你可以在这里找到它的描述。 观察一下它的描述： SYNOPSIS #include /* Definition of SYS_* constants */ #include pid_t syscall(SYS_set_tid_address, int *tidptr); Note: glibc provides no wrapper for set_tid_address(), necessitating the use of syscall(2). DESCRIPTION For each thread, the kernel maintains two attributes (addresses) called set_child_tid and clear_child_tid. These two attributes contain the value NULL by default. set_child_tid If a thread is started using clone(2) with the CLONE_CHILD_SETTID flag, set_child_tid is set to the value passed in the ctid argument of that system call. When set_child_tid is set, the very first thing the new thread does is to write its thread ID at this address. clear_child_tid If a thread is started using clone(2) with the CLONE_CHILD_CLEARTID flag, clear_child_tid is set to the value passed in the ctid argument of that system call. The system call set_tid_address() sets the clear_child_tid value for the calling thread to tidptr. When a thread whose clear_child_tid is not NULL terminates, then, if the thread is sharing memory with other threads, then 0 is written at the address specified in clear_child_tid and the kernel performs the following operation: futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0); The effect of this operation is to wake a single thread that is performing a futex wait on the memory location. Errors from the futex wake operation are ignored. RETURN VALUE set_tid_address() always returns the caller's thread ID. ERRORS set_tid_address() always succeeds. 会发现这个 set_child_tid 和 clear_child_tid 的描述都是用 If a thread is started using clone(2) with... 开头的，这里的 clone 是 sys_clone，本质上和我们的 sys_fork 同功能，但提供更多的参数。因为目前内核里对 fork 没有更多的参数支持，我们也显然不会满足这里提到的 If，所以这两个情况目前都是不必要的。 由于 clear_child_tid 在目前的内核中不存在，所以下一行说的 sets the clear_child_tid value for the calling thread to tidptr. 的情况也可以忽略，这样连这个 syscall 的唯一参数 tidptr 也可以不用管，我们直接看返回值就好了。 选择忽略哪些描述、实现哪些描述并不简单。一般情况下，可以运行一个用户程序，看它在调用这个 syscall 的时候给了哪些参数，然后在内核中选择性忽略它没有给的参数。不过有时候用户程序给出的参数也是不必要的，这需要反复 debug 才能知道。 返回值告诉我们，这里需要返回调用者的线程 ID。考虑 rCore-Tutorial 和实际 Linux 的线程定义差异（下一节详细说明），我们在此返回 pid。这样我们直接使用已有的 sys_getpid() 函数就好了。 注意，返回 sys_getpid 而不是 sys_gettid！ 重复一遍，返回 sys_getpid 而不是 sys_gettid！ 我们在 os/src/syscall/mod.rs 添加上这个 syscall： /// set_tid_address syscall pub const SYSCALL_SET_TID_ADDRESS: usize = 96; /// handle syscall exception with `syscall_id` and other arguments pub fn syscall(syscall_id: usize, args: [usize; 4]) -> isize { match syscall_id { ...... SYSCALL_SET_TID_ADDRESS => sys_getpid(), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } } 再次运行程序...随后它就会卡在另一个 syscall 上：Unsupported syscall_id: 29。 不过接下来就是你的任务了：看看布置实验那一节的要求，补上缺失的 syscall 使得 hellostd 测例运行成功。 "},"docs/lab2/tid.html":{"url":"docs/lab2/tid.html","title":"规范：TID 定义问题","keywords":"","body":"规范：TID 定义问题 rCore-Tutorial 的接口设计受到 zircon 影响，且为了教学简化了许多模块的设计。但在支持实际的 Linux 应用时，我们需要改掉这些设计。 本节介绍rCore-Tutorial 的 tid 与标准 tid 有何不同，之后会有更多这样的小节说明rCore-Tutorial其他模块中的规范问题。 POSIX syscall 的定义 在 Linux 中，每个线程有全局唯一的线程ID，也就是 tid，且每个进程的初始线程的 tid 等同于进程的 pid。举个例子来说，可能是这样： 线程 pid tid a 1 1 b 2 2 c 1 3 d 1 4 e 5 5 这里 a,c,d 是同一个进程里的线程，b e 分别是独立的进程。再举几个例子： 如果往 a,c,d 里再加一个线程 f，它可能是 pid=1,tid=6，当然其他大于 6 的 tid 也是合法的。 如果进程 d 退出，然后其他进程再创建一个进程 d2，那么它可能是 pid=4,tid=4，也可能是其他的 pid=x,tid=x(x>=6)。总之，tid不能重复。 rCore-Tutorial 而相对的，在 rCore-Tutorial 中，每个进程内部的每个线程的ID独立排序，且每个进程的初始线程的 tid 为 0。也就是像下面这样 线程 pid tid a 1 0 b 2 0 c 2 1 d 3 0 e 2 2 f 1 1 这里 a,f 是同一个进程内的两个线程，b,c,e 是同一个进程内的三个线程，d 是一个独立进程。 实现建议 在通过比赛测例时，你需要修改 tid 实现以适应实际 Linux 应用的需求。但在本次实验中不需要改下面的实现。 所以我们在修改 tid 的实现时，可以把 tid 改成原来那个全局唯一的 pid，也即 每次生成一个进程时，为它分配一个全局ID作为 tid。然后令它的 pid 的值为 tid。 每次生成一个线程时，也为它分配一个全局ID作为 tid。然后令它的 pid 的值为生成它的线程的 pid（这表示它们俩在同一个进程里） 扩展阅读：waittid 如果认真看 syscall列表和 sys_wait 的文档，你可能会注意到这里没有 waittid，只有 wait,waitpid,waitid（注意 waitid=wait+id）。那么 Linux 应用如何实现 rCore-Tutorial 的 waittid 呢？你可能已经在其他项目中见过它的形式了： int pthread_join(pthread_t, void **); 在 musl 源码中，pthread_join 最终会调用 src/thread/pthread_join.c/__pthread_timedjoin_np。我们可以简单分析这个函数是如何实现等待一次线程退出的： static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) { int state, cs, r = 0; __pthread_testcancel(); __pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs); if (cs == PTHREAD_CANCEL_ENABLE) __pthread_setcancelstate(cs, 0); while ((state = t->detach_state) && r != ETIMEDOUT && r != EINVAL) { if (state >= DT_DETACHED) a_crash(); r = __timedwait_cp(&t->detach_state, state, CLOCK_REALTIME, at, 1); } __pthread_setcancelstate(cs, 0); if (r == ETIMEDOUT || r == EINVAL) return r; __tl_sync(t); if (res) *res = t->result; if (t->map_base) __munmap(t->map_base, t->map_size); return 0; } 其中， 两次 __pthread_setcancelstate 分别表示关闭/打开取消请求。线程可以通过 pthread_cancel 函数去试图终止其他线程的运行，但其他线程也可以设置是否响应。在 __pthread_timedjoin_np 里的这两句 __pthread_setcancelstate 中间的代码运行时，当前线程是不会响应取消请求的。你可以类比内核中“关闭异常中断”的过程。 __timedwait_cp 会使用一个 sys_futex 在某个内存地址设置一个条件变量。你可以将它理解为类似 rCore-Tutorial ch8 中条件变量一节的实现。 当当前线程所等待的那个线程退出时，它会修改表示线程状态的条件变量的值。这些条件变量的地址和上一节中我们“跳过实现”的 sys_set_tid_address 的参数有关。 这会唤醒正在等待的当前线程，使它获取返回结果 r 并继续执行。 "},"docs/lab2/exercise.html":{"url":"docs/lab2/exercise.html","title":"练习","keywords":"","body":"练习 编程作业 可以使用前一个实验完成后的代码来做本实验。如果没有完成前一个实验，也可以从 rCore-Tutorial ch8 开始修改，不影响实验本身。如果没有做到 ch8，也可以用全新的 ch7 来做实验。 在本实验中，你需要： 跟随前面文档的指引修改内核，使得运行测例 hellostd 可以输出 Unsupported syscall_id: 29。 根据 通过 Manual Page 添加 Syscall 一节中介绍的方法，添加其他 syscall，使得测例 hellostd 可以正常运行并输出 hello std。（提示：只有一个新的 syscall 需要实现，其他的都可以用内核中现有 syscall 代替或者什么都不做直接返回 0） 问答作业 查询标志位定义。 标准的 waitpid 调用的结构是 pid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);。其中的 options 参数分别有哪些可能（只要列出不需要解释），用 int 的 32 个 bit 如何表示？ 你可能需要根据通过 Manual Page 添加 Syscall一小节的指引下载 musl 源码，并用寻找报错位置 中提到的全局搜索技巧进行分析。 报告要求 完成编程作业，描述实现思路以及修改的代码。本章没有自动评测，我们会人工检查你的代码实现和报告。 完成问答题。 推荐使用 markdown 格式 和 rCore-Tutorial 实验类似，报告放在 reports/文件夹下，但命名为 labr2.md或labr2.pdf "}}