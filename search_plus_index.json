{"./":{"url":"./","title":"实验简介","keywords":"","body":"从 rCore-Tutorial 到实际应用 本教程是 rCore-Tutorial 的后续教程，希望能帮助大家从 rCore-Tutorial 以及其他 Rust 内核出发，构建一个可运行原生 Linux 应用、拥有更强大功能的内核。如果你是希望参加全国大学生计算机系统能力大赛操作系统设计赛的同学，可以通过本教程学习如何构建自己的内核；如果你是其他 Rust 开发者，也可以通过本教程扩展 rCore-Tutorial，用学到的知识为开源社区做贡献。 本教程的各个实验间不是连续的。我们会选择内核开发中的一些小切片，以它们为例设计代码量适中的实验，引导大家在OS比赛中的开发。如果说 rCore-Tutorial 是十层居民楼的毛坯房，需要大家通过 5 个实验去“装修”，那么本教程就像是一个个更高楼房的地基，指引大家从这里开始建造摩天大楼。 目前本教程被用作开源操作系统训练营（见 github 首页说明）的实践项目。 为什么会有这个教程？ rCore-Tutorial 是一个用 Rust 写操作系统的教程。当你做完这个教程，就已经获得了一个支持文件系统、线程等特性，包含约 50 个 syscall 的操作系统内核。 不过，如果想要进一步扩展这个内核，就会出现其他问题： rCore-Tutorial 的文件系统、测例自成一体，最后完成的内核也只能运行它自己的文件系统、跑自己的测例，和通用测例集乃至真正的 Linux 应用不兼容。 syscall 并不完全和 POSIX 接口兼容。部分 syscall 是来自 Zircon，还有一部分是为了实验考察而添加的仅用于实验本身的 syscall 模块划分不完善，模块化程度不高，沿用框架开发到后期会比较痛苦 有经验的同学可以自行重构 rCore-Tutorial，或者重新写一个内核来参加OS比赛。但大多数只学过 rCore-Tutorial 的同学来说，这样的重构并不在它教程的范围内，因此修改 rCore-Tutorial 就成了参赛的一道门槛。 本教程的目的是帮助大家跨过这道门槛，能够将更多精力投入到内核本身的开发中。 实验形式 本教程中的实验参考 rCore-Tutorial，分为代码实验和思考题，每一章节需要提交报告。但也有以下不同： 整个教程没有统一的仓库，部分实验需要使用 rCore-Tutorial 仓库，部分实验自带另一个仓库。 实验参考了 rustlings 教程的形式，边做边学，跟随教程指引就可以完成大部分代码工作，而章节末尾的代码实验预期会需要更少的时间。 "},"docs/lab1/intro.html":{"url":"docs/lab1/intro.html","title":"实验概述","keywords":"","body":"运行裸机 C 程序 建议至少做完 rCore-Tutorial ch6 再做这个实验。 实验准备 本实验需要用到交叉编译的工具链：https://musl.cc/riscv64-linux-musl-cross.tgz。下载解压后将里面的 bin 目录放到你的 PATH 中，然后尝试使用以下命令 riscv64-linux-musl-gcc --version 来检查是否安装成功。 如果忘了怎么安装这类包，可以看rCore-Tutorial 指导书第0章环境配置中安装 Qemu 模拟器一节，操作是类似的。 实验概述 在往年的 rCore-Tutorial 实验中，有些同学会有这样一种感受：整个 rCore-Tutorial 是一个完整的项目，从内核到测例到文件系统都是用 Rust 连接的，修改任何一部分都需要做额外的兼容。就像下面这样： 但其实这中间都是二进制接口，只是被实验仓库里完善的脚本掩盖了。我们可以任意更换这其中的每个部分，而不需要做另外的适配： 在本章中，我们将回顾用户程序的编译与加载流程，然后使用一个极简的 C 用户程序库代替 rCore-Tutorial 原有的 /user 测例，并修改上面这套编译、打包、加载的流程中的各个 Makefile，让原本只支持 rCore-Tutorial 自带的 Rust 测例的内核运行一个从 C 语言编译的应用程序。 在实验之后 运行 C 用户程序是OS比赛初赛的第一步。如果你正在参赛或者准备参赛，那么在完成这个实验之后，还有下面这些工作要做 尝试通过比赛初赛测例库 比赛初赛测例库 可以直接访问，通过它也就通过了初赛。这个测例库比当前实验里要稍微复杂一些，但功能上相比 rCore-Tutorial 不会有太大变化。注意比赛的 syscall 规范和 rCore-Tutorial 的会有细微差别。 更换一个 FAT32 类型的文件系统 这是比赛初赛的要求。你可以自己写一个，也可以参考往年获奖作品的实现，也可以使用现有的开源项目，比如rust-fatfs。 FAT32 的好处在于，它是一个公共的文件系统格式。因此可以直接用 dd 和 mkfs.vfat 命令创建一个镜像（具体要求看比赛），然后直接在本地挂载它就可以往里塞文件了，完全不需要 easy-fs-fuse： # in makefile -mkdir temp sudo mount ./fs.img temp -sudo cp -r -a ./testcases/* ./temp/ sudo umount ./fs.img rmdir temp 这段命令把 fs.img挂载到 temp 文件夹中，然后把 testcases 里的所有测例都塞了进去，实际上和 easy-fs-fuse 做的事情是一样的。 顺便一提，- 开头的命令会如果执行失败，则 makefile 仍然继续进行下面的命令。 第一条指令的 - 是因为目录本身可能已存在，第三条指令的 - 开头是因为本地文件系统中可能有符号链接，它们在被复制进不支持链接的 FAT32 时会报错。无论如何，我们希望第三行指令执行完成后必须执行第四行指令 umount ./fs.img ，也就是取消 fs.img 的挂载。否则宿主机上可能会因为一次 make 失败而永远挂着这么一个文件系统。 考虑离线编译 截至目前，比赛的评测机不支持联网。因此，你可能需要为内核准备一个“离线”编译模式。具体来说，需要在内核 cargo build 的地方加上参数 --offline，然后在这个模式下将所有评测机不支持的依赖库拉到项目里。可以用 Makefile 变量等方式来控制这个参数。 如果本地网络不是很好的话，这种离线编译方式也许能为本地调试节省一些时间。毕竟，编译 Rust 项目时卡在拉取依赖库上实在是太常见了。 "},"docs/lab1/toelf.html":{"url":"docs/lab1/toelf.html","title":"编译到二进制代码","keywords":"","body":"编译到二进制文件 在 ch6 中，rCore-Tutorial 指导书详细介绍了应用程序运行时如何读写文件、文件系统 easy-fs 的实现以及内核如何与文件系统交互。但对于用户程序如何在编译后被塞进文件系统这个过程，指导书讲得比较粗略，容易让大家以为用户程序和文件系统是以某种“魔法”联系在一起的。 现在我们先暂时跳出内核，破解这一层魔法。 分析 user/Makefile 在 user文件夹下，运行 make build CHAPTER=8 BASE=2 这一步会将所有 ch8 及之前的测例编译后放一份到 user/build/elf/ 中，然后将每个应用删除 ELF header 符号得到纯二进制的镜像，放到 user/build/bin/，如同 ch2 “实现应用程序”一节介绍的那样。但和 ch2 不同的是，这些ELF文件会被放到文件系统里，而不是直接链接进内核。 我们可以看 user/Makefile 这个文件了解 make build 时发生了什么： ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) binary: @echo $(ELFS) @if [ ${CHAPTER} -gt 3 ]; then \\ cargo build $(MODE_ARG) ;\\ else \\ CHAPTER=$(CHAPTER) python3 build.py ;\\ fi @$(foreach elf, $(ELFS), \\ $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf)); \\ cp $(elf) $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.elf, $(elf));) ...... pre: @mkdir -p $(BUILD_DIR)/bin/ @mkdir -p $(BUILD_DIR)/elf/ @mkdir -p $(BUILD_DIR)/app/ @mkdir -p $(BUILD_DIR)/asm/ @$(foreach t, $(APPS), cp $(t) $(BUILD_DIR)/app/;) build: clean pre binary @$(foreach t, $(ELFS), cp $(t).bin $(BUILD_DIR)/bin/;) @$(foreach t, $(ELFS), cp $(t).elf $(BUILD_DIR)/elf/;) clean: @cargo clean @rm -rf $(BUILD_DIR) build: clean pre binary 告诉我们 build 这个任务依赖于后面的三个任务，所以只需要把这几个任务单独拉出来看： ELFS 定义了所有测例对应的 ELF 文件。patsubst 这个命令的意思是，把 $(APPS) 中每一个形如 $(APP_DIR)/%.rs 这样的字符串找出来，把它替换成 $(TARGET_DIR)/%（符号 % 对应前面 $(APP_DIR)/%.rs 那里的 % 表示的字符串），然后把所有替换后的串交给 ELFS。比如 src/bin/ch6_file0.rs 会被替换成 target/riscv64gc-unknown-none-elf/release/ch6_file0。 clean 删除了 cargo 也就是 Rust 编译后的临时文件，然后删除 build 目录 pre 创建了 build 目录以及下属的几个子目录，app elf bin 分别存放测例代码、测例编译后的 ELF 文件、ELF 文件删除元信息后的纯可执行文件。然后把代码复制一份，存到 app 目录下。 asm 下是空的，它会在另一个叫 disasm 的任务被用到 binary 首先用 if [ ${CHAPTER} -gt 3 ]; 检查编译的章节是否大于 3，大于 3 则使用 Rust 的编译器 cargo 编译，否则使用 python。随后，它会把 $(ELFS) 中所有文件的调试段删掉，命名为对饮的 .bin 文件。然后把 $(ELFS) 中所有文件复制一份，命名为对应的 .elf 文件。 如果你还记得的话，在 ch3 及之前我们的内核是“批处理操作系统”，所以需要依赖其他程序（代码框架里用的 python）做链接 最后 build 任务会把上一步 binary 生成的 .bin 和 .elf 文件分别复制一份到 $(BUILD_DIR)/bin/ 目录和 $(BUILD_DIR)/elf/ 目录。 检查二进制文件的内容 接下来在 user/build/elf/ 下运行 rust-objdump --arch-name=riscv64 -ld ch6_file0.elf > debug.S，可以在文件中看到像这样的输出 ch6_file0.elf: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 : ; _start(): 0: 0d 71 addi sp, sp, -352 2: 86 ee sd ra, 344(sp) 4: 2e fc sd a1, 56(sp) 6: aa e0 sd a0, 64(sp) 8: aa f5 sd a0, 232(sp) a: ae f9 sd a1, 240(sp) c: 97 00 00 00 auipc ra, 0 10: e7 80 20 5f jalr 1522(ra) ...... 这是一个 elf 格式的可执行文件。如果你看过 rCore-Tutorial 指导书的附录 B 的话可能会对这个形式有印象。这个测例的可执行文件与整个 OS 的可执行文件并没有什么不同。例如你可以在文件中找到： _start 是整个程序的入口，也就是 os/src/task/process.rs 中调用 MemorySet::from_elf 拿到的 entry_point。 文件中的 ecall 指令实际上就是内核中看到的 syscall 调用的来源。在 ecall 指令之前通常在操作 a7 以及 a0 a1 a2 等寄存器，这就是内核在 os/src/trap/mod.rs:trap_handler 中看到的 let result = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12], cx.x[13]]); 所调用的几个寄存器。 下一节我们会详细带大家分析一个类似文件的内容。 虽然我们用 Rust 编译了它，并且用 rust-objdump区查看它的反汇编，但到这一步这个文件已经和 Rust 无关了。我们可以尝试改用前面安装的交叉编译工具链，运行 riscv64-linux-musl-objdump -ld ch6_file0.elf > debug.S，可以在文件中看到这样的输出 ch6_file0.elf: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 : _start(): 0: 710d addi sp,sp,-352 2: ee86 sd ra,344(sp) 4: fc2e sd a1,56(sp) 6: e0aa sd a0,64(sp) 8: f5aa sd a0,232(sp) a: f9ae sd a1,240(sp) c: 00000097 auipc ra,0x0 10: 5f2080e7 jalr 1522(ra) # 5fe ...... 虽然排版上略有不同，且对函数调用地址给出了注释信息，但二进制文件本身是相同的。这意味着，我们可以用交叉编译工具链中的 gcc 编译一个 C 程序，把它塞到文件系统镜像里，它应该也能像 user 库里的 Rust 测例一样正常运行。不过这里还有一些细节问题，我们之后再讲这件事。 "},"docs/lab1/clib.html":{"url":"docs/lab1/clib.html","title":"测例库介绍","keywords":"","body":"测例库介绍 从这里可以获取到本次实验需要使用的用户程序。你需要把 lab1 分支下的 testcases 目录放到当前实验（也就是 2023a-rcore- 开头的这个项目）的根目录下，在 testcases 目录下运行 make build 即可在 testcases/build/ 下获得 42 hello两个二进制文件。 测例里都有什么 这是一个极简的测例库，可以编译不依赖于 libc 的 C 程序。事实上，它对标的是比赛初赛测例库（ https://github.com/oscomp/testsuits-for-oskernel/tree/master/riscv-syscalls-testing ）的超级简化版。 我们可以像上一节一样，在 build 目录下使用 riscv64-linux-musl-objdump -ld 42 > debug.S 检查这个可执行文件的内容。相对于其他汇编来说，其实它非常短，例如用标准库编译一个 hello world 有大概 5000 行。 其中的每一行，例如 100b0: 1141 addi sp,sp,-16 表示这一条指令的地址在 100b0，数值是 1141，这个数值的含义是一条 RISC-V 指令 addi sp,sp,-16。读懂里面发生的每一件事可能需要有一点 RISC-V 汇编语言基础，但不懂也没关系，我们会在代码下面解释它的内容： 42: file format elf64-littleriscv Disassembly of section .text: 00000000000100b0 : main(): 100b0: 1141 addi sp,sp,-16 100b2: e422 sd s0,8(sp) 100b4: 0800 addi s0,sp,16 100b6: 02a00793 li a5,42 100ba: 853e mv a0,a5 100bc: 6422 ld s0,8(sp) 100be: 0141 addi sp,sp,16 100c0: 8082 ret 00000000000100c2 : __start_main(): 100c2: 7179 addi sp,sp,-48 100c4: f406 sd ra,40(sp) 100c6: f022 sd s0,32(sp) 100c8: 1800 addi s0,sp,48 100ca: fca43c23 sd a0,-40(s0) 100ce: fd843783 ld a5,-40(s0) 100d2: 639c ld a5,0(a5) 100d4: fef42623 sw a5,-20(s0) 100d8: fd843783 ld a5,-40(s0) 100dc: 07a1 addi a5,a5,8 100de: fef43023 sd a5,-32(s0) 100e2: fec42783 lw a5,-20(s0) 100e6: fe043583 ld a1,-32(s0) 100ea: 853e mv a0,a5 100ec: fc5ff0ef jal ra,100b0 100f0: 87aa mv a5,a0 100f2: 853e mv a0,a5 100f4: 09c000ef jal ra,10190 00000000000100f8 : __syscall1(): 100f8: 1101 addi sp,sp,-32 100fa: ec22 sd s0,24(sp) 100fc: 1000 addi s0,sp,32 100fe: fea43423 sd a0,-24(s0) 10102: feb43023 sd a1,-32(s0) 10106: fe843883 ld a7,-24(s0) 1010a: fe043503 ld a0,-32(s0) 1010e: 00000073 ecall 10112: 87aa mv a5,a0 10114: 853e mv a0,a5 10116: 6462 ld s0,24(sp) 10118: 6105 addi sp,sp,32 1011a: 8082 ret ...... 0000000000010190 : exit(): 10190: 1101 addi sp,sp,-32 10192: ec06 sd ra,24(sp) 10194: e822 sd s0,16(sp) 10196: 1000 addi s0,sp,32 10198: 87aa mv a5,a0 1019a: fef42623 sw a5,-20(s0) 1019e: fec42783 lw a5,-20(s0) 101a2: 85be mv a1,a5 101a4: 05d00513 li a0,93 101a8: f51ff0ef jal ra,100f8 101ac: 0001 nop 101ae: 60e2 ld ra,24(sp) 101b0: 6442 ld s0,16(sp) 101b2: 6105 addi sp,sp,32 101b4: 8082 ret 00000000000101b6 : _start(): 101b6: 850a mv a0,sp 101b8: b729 j 100c2 _start 是整个程序的入口，它会将 sp 复制到 a0，相当于函数参数，然后调用 __start_main。这个参数并不直接等价于我们熟知的 argc 或argv，我们下面再详细介绍。 __start_main 是一个库提供的初始化函数。它初始化完成后，会调用 C 代码里用户程序自己的 main 函数。 main函数只是返回了一个 42，然后 __start_main 调用了 exit exit 其实相当于 sys_exit，也就是大家在 ch3 接触到的第一个 syscall，用于退出用户程序。在这段汇编中，它填好参数后会调用 __syscall1 最后 __syscall1 通过 ecall 陷入内核，通知内核这个用户程序结束了，且返回值是 42。ecall 后面的代码不会被执行到。 也可以直接看 C 的源代码。其中比较关键的是 lib\\main.c： int __start_main(long *p) { int argc = p[0]; char **argv = (void *)(p+1); exit(main(argc, argv)); return 0; } 其中输入参数 p 是 _start 调用 __start_main 时给的，实际上就是初始的用户栈指针。 main.c 中将初始用户栈指针 p 指向的值设为 argc，然后将 p+1 的值设为 argv。也就是说，用户栈上的空间大致是这样的 position content size (bytes) ------------------------------------------------------------------------ stack pointer -> [ argc = number of args ] 8 [ argv[0] (pointer) ] 8 (program name) [ argv[1] (pointer) ] 8 [ argv[..] (pointer) ] 8 * x [ argv[n - 1] (pointer) ] 8 [ argv[n] (pointer) ] 8 (= NULL) [ argv[0] ] >=0 (program name) [ '\\0' ] 1 [ argv[..] ] >=0 [ '\\0' ] 1 [ argv[n - 1] ] >=0 [ '\\0' ] 1 ------------------------------------------------------------------------ 注意从上到下是地址从低到高，而用户栈向低地址扩展。栈顶是 argc， 接下来是 argv 数组，它们依次指向每个真正的 argv[i] 字符串。 如果还对 ch7 的命令行参数一节有印象，可能很快就会发现，上面的栈排布和 ch7 指导书教的不太一样。事实上，上面的排布是符合 ELF 文件规范的（见 About ELF Auxiliary Vectors，网页中的 4 在我们这里换成了 8，因为目标架构 riscvgc64 是 64 位），而 rCore-Tutorial 指导书里的写法只能仅供学习参考。 为了支持原生的 Linux 应用，后续最好还是改用这里介绍的写法。 为什么使用这样一个测例项目 为什么我们要绕这么一个大弯，去手写一个测例库呢？你可能会想试试写一个最简单的 hello world： #include int main() { printf(\"hello world\"); } 然后用交叉编译器直接编译后看汇编，其实也没有多少行。但注意，这种方式生成出的可执行程序使用了动态链接，这是一项比赛复赛时才会涉及的功能，目前我们的内核是无法运行这样的程序的。例如在这段汇编中甚至无法找到一个 ecall，这不是说这个用户程序不会执行 syscall，而只是它跳转到了外部的共享库中执行。如果感兴趣，可以在搜索引擎搜索“动态链接”简单了解。 当然也可以指定静态编译。假设上面的 hello world 是 a.c，使用 riscv64-linux-musl-gcc a.c -static 即可。这样得到的可执行文件不依赖外部库了，但有超过 5000 行，很难调试。你也可以在目前的内核中尝试运行它，看看是否会报错。 总之，使用标准库函数（如 printf ）的 C 用户程序不是这次实验要处理的问题。这就是为什么我们手写了一个测例库用于实验。 使用用户态 qemu 进行对拍 测例库里编译的测例都是完全符合规范的 RISC-V 可执行程序，所以它当然可以在其他内核上运行。 如果你还记得，在 rCore-Tutorial的 ch0配环境的时候，安装了 qemu-riscv64 和 qemu-system-riscv64。后者用于运行实验，而前者实际上是一个用户态模拟器。换而言之，它可以直接运行用户态的 RISC-V 程序，我们可以直接把测例文件扔给它。 例如在 testcases/ 目录下执行 qemu-riscv64 ./build/hello，就可以获取正确输出（可以打开 testcases/src/hello.c 看看正确输出长什么样）。 同样地，也可以执行 qemu-riscv64 ./build/42。这个用户程序在退出时返回了一个 42，不过没有打印输出。但我们可以在上面的命令之后立即执行 echo $? 就可以看到返回值 42 $? 是一个shell的变量，表示上一条命令的返回值。 在这个例子中，具体来说是 qemu 的返回值。它执行了我们要求的用户程序，然后把用户程序的返回值作为自己的返回值，推给宿主机。 如此一来，后续我们每次遇到一个新的应用程序，就可以用 qemu-riscv64 进行检查，看看正常的“内核”运行它应该是什么样的，然后来推测我们的内核运行同一个测例时出了什么错。 我们把这种调试方式叫做“对拍”。 "},"docs/lab1/tofs.html":{"url":"docs/lab1/tofs.html","title":"打包进文件系统","keywords":"","body":"打包进文件系统 现在我们已经可以统一 Rust 和 C 的测例了，但现在的 rCore-Tutorial 只支持自动编译 并打包/user 下的测例，怎么把其他测例也放进 easy-fs 呢？ graph LR; /user里的Rust用户程序--编译-->ELF文件 其他用户程序--编译-->ELF文件 ELF文件--/user下的测例自动打包--->easy-fs ELF文件-.如何放进其他测例?.->easy-fs 在 ch6 中，我们知道 easy-fs-fuse 模块负责将用户程序打包成满足 easy-fs 格式的文件系统镜像。既然上面已经分析出 C 的应用和 Rust 的应用赛道文件系统镜像里没什么两样，现在我们就可以扩展这个模块，使得它可以生成同时包含 Rust 和 C 用户程序的镜像。（下面的说明只是其中一种做法，你可以用自己的方式完成这一步！） 其实，如果想要让内核支持 C 应用程序，可以一步到位，直接撇开原本的 user 库，只编译 C 的程序（比赛初赛的测例就完全没有 Rust 的用户程序）。 但由于本来的 rCore-Tutorial 实验已经包含了带 initproc 和 user_shell 的 Rust 用户程序，直接抛弃这些支持就会让调试过程重回 ch3/ch4 的状态，并且也难以利用已通过的大量 rCore 测例检查有没有改错东西，这对基础弱的同学不太友好。 因此，我们选择了折衷的方式进行讲解，让本实验中的内核可同时接收 C 和 Rust 的用户程序。 首先，我们来找找 easy-fs-fuse 是什么时候被调用的。 当在 os 文件夹下运行 make run时，文件系统镜像会自动生成。观察 os/Makefile文件，可以发现 run 命令依赖于 build，build 命令依赖于 fs-img，这就是我们要找的命令了。 fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @rm -f $(FS_IMG) @cd ../easy-fs-fuse && cargo run --release -- -s ../user/src/bin/ -t ../user/target/riscv64gc-unknown-none-elf/release/ 回顾 ch6，最后这条命令的逻辑是，从 -s 后的目录 ../user/src/bin 中获取所有测例的名字，然后在 -t 后的目录 ../user/target/riscv64gc-unknown-none-elf/release/ 中依次找到对应的 ELF 文件，加入到文件系统镜像中。文件系统镜像最终会被放在 -t 后的目录（见 os/Makefile 开头 FS_IMG 的定义）。 这个 -s 有点啰嗦，我们只需要知道什么文件应该被打包，不需要知道它们的源文件是什么，况且之后要支持的 C 用户程序是不会有 Rust 的源文件的。由此可以修改一下这里 -s 和 -t 的语义： -s 之后的目录定义为要打包塞进文件系统镜像中的目录。 easy-fs-fuse 会依次寻找目录中的文件塞进文件系统镜像里。 -t之后的目录仅用来存放最终生成的文件系统镜像。 然后把命令重写成： FS_IMG := target/fs.img ...... fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @rm -f $(FS_IMG) @cd ../easy-fs-fuse && cargo run --release -- -s ../user/build/elf/ -t ../os/target/ 其中 FS_IMG 是 os/Makefile 开头定义的变量。按照新的语义，此时 fs-img 命令的逻辑就变成了“将 ../user/build/elf” 中的所有文件打包成文件系统镜像，放在 ../os/target/ 里。当然，还需要修改 easy-fs-fuse 使之满足新的语义： // easy-fs-fuse/src/main.rs let root_inode = Arc::new(EasyFileSystem::root_inode(&efs)); /* let apps: Vec = read_dir(src_path) .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); for app in apps { // load app data from host file system let mut host_file = File::open(format!(\"{}{}\", target_path, app)).unwrap(); let mut all_data: Vec = Vec::new(); host_file.read_to_end(&mut all_data).unwrap(); // create a file in easy-fs let inode = root_inode.create(app.as_str()).unwrap(); // write data to easy-fs inode.write_at(0, all_data.as_slice()); } */ for dir_entry in read_dir(src_path).unwrap().into_iter() { let dir_entry = dir_entry.unwrap(); let path = dir_entry.path(); let file_name = dir_entry.file_name().into_string().unwrap(); let base_name = &file_name[..file_name.rfind('.').unwrap_or(file_name.len())]; let mut host_file = File::open(&path).unwrap(); let mut all_data: Vec = Vec::new(); host_file.read_to_end(&mut all_data).unwrap(); // create a file in easy-fs let inode = root_inode.create(base_name).unwrap(); // write data to easy-fs inode.write_at(0, all_data.as_slice()); } 对比原本的代码（上面的注释）和修改后的新代码： src_path 目录原本被用来寻找所有源代码文件的名字，生成 apps 后再从 target_path中找对应的文件；修改后，代码通过 read_dir(src_path).unwrap().into_iter() 直接从 src_path 中去寻找文件塞进文件系统镜像里。 原本的代码中，通过 name_with_ext.find('.').unwrap() 找到每一个文件的后缀名，然后通过 name_with_ext.drain 删除，如果文件名中不包含 .，整个 easy-fs-fuse 就会报错。现在的代码通过 file_name.rfind('.') 寻找最后一个后缀名并删除，如果文件名中不包含 .，则会取文件全名。 当然，在现在的实现中，如果出现两个文件仅有后缀名不同的情况，会导致出错，不过这种检查也很容易实现。 可不可以不去除后缀名，直接原封不动把文件放到镜像里？ 可以，但比较麻烦。我们之所以一定要执着地去除后缀名，是因为可执行程序一般默认是无后缀的。如内核启动时首先会去找 initproc，这个用户程序又会去找 user_shell，而每一章的 usertest 也会去找每一个对应章节的测例。如果所有这些地方都考虑后缀，代码改起来就会很麻烦。不过，过渡到只是用 C 语言用户程序的初赛时，可以考虑把去后缀这一步删掉。 还可以把这段修改下面的几行代码 for app in root_inode.ls() { println!(\"{}\", app); } 前的注释删掉以便观察最终被打包的文件有哪些。现在我们回到 os 目录，执行 fs-img CHAPTER=8 BASE=2 可以看到我们修改过的 easy-fs-fuse 正确打包了文件。 如何将 C 语言测例也包括进来呢？ 别忘了 C 的用户程序在 testcases里。我们像 user 那样也调用一次 make build 生成可执行文件，然后把两拨测例复制到一起，再交给 easy-fs-fuse 打包就可以了。现在我们再次修改 os/Makefile 中的 fs-img 命令如下 fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @make -C ../testcases build @rm -f $(FS_IMG) @cp ../user/build/elf/* ../testcases/build/ @cd ../easy-fs-fuse && cargo run --release -- -s ../testcases/build/ -t ../os/target/ 现在我们可以同时打包 Rust 和 C 的用户程序了！ 再次在os 目录执行 fs-img CHAPTER=8 BASE=2，就可以唤出 usershell 了，现在你可以尝试运行本实验所使用的两个 C 语言用户程序了。 "},"docs/lab1/exercise.html":{"url":"docs/lab1/exercise.html","title":"练习","keywords":"","body":"练习 编程作业 完成 rCore-Tutorial 的同学可以从 ch8 开始修改。如果没有做到 ch8，也可以用全新的 ch7 来做实验。 在本实验中，你需要： 跟随前面文档的指引，扩展 easy-fs-fuse，使得它可以生成同时包含 Rust 和 C 用户程序的镜像 在 usershell 里运行了 42 和 hello 两个用户程序。42 的运行结果是符合预期的，但 hello 的结果看起来不太对，你的任务是修改内核，使得 hello 测例给出正常输出（即给出一行以 my name is 开头的输出，且 exit_code为0）。 问答作业 elf 文件和 bin 文件有什么区别？ Linux 的 file 命令可以检查文件的类型，尝试执行以下命令，描述看到的现象，然后尝试解释输出 # 在 user/build/elf/ 下 file ch6_file0.elf # 在 user/build/bin/ 下 file ch6_file0.bin riscv64-linux-musl-objdump -ld ch6_file0.bin > debug.S 如果对应目录下没有文件，请在 user/ 目录执行 make build CHAPTER=8 BASE=2 报告要求 完成编程作业，描述实现思路以及修改的代码。本章没有自动评测，我们会人工检查你的代码实现和报告。 完成问答题。 推荐使用 markdown 格式 和 rCore-Tutorial 实验类似，报告放在 reports/文件夹下，但命名为 labr1.md或labr1.pdf "}}