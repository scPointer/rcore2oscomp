{"./":{"url":"./","title":"实验简介","keywords":"","body":"从 rCore-Tutorial 到实际应用 本教程是 rCore-Tutorial 的后续教程，希望能帮助大家从 rCore-Tutorial 以及其他 Rust 内核出发，构建一个可运行原生 Linux 应用、拥有更强大功能的内核。如果你是希望参加全国大学生计算机系统能力大赛操作系统设计赛的同学，你可以通过本教程学习如何构建自己的内核；如果你是其他 Rust 开发者，你可以通过本教程扩展 rCore-Tutorial，用学到的知识为开源社区做贡献。 本教程的各个实验间不是连续的。我们会选择内核开发中的一些小切片，以它们为例设计代码量适中的实验，引导大家在OS比赛中的开发。如果说 rCore-Tutorial 是十层居民楼的毛坯房，需要大家通过 5 个实验去“装修”，那么本教程就像是一个个更高楼房的地基，指引大家从这里开始建造摩天大楼。 目前本教程被用作开源操作系统训练营（见 github 首页说明）的实践项目。 为什么会有这个教程？ rCore-Tutorial 是一个用 Rust 写操作系统的教程。当你完成它时，相信你已经获得了一个支持文件系统、线程等特性，包含约 50 个 syscall 的操作系统内核。 不过，如果想要进一步扩展这个内核，就会出现其他问题： rCore-Tutorial 的文件系统、测例自成一体，最后完成的内核也只能运行它自己的文件系统、跑自己的测例，和通用测例集乃至真正的 Linux 应用不兼容。 syscall 并不完全和 POSIX 接口兼容。部分 syscall 是来自 Zircon，还有一部分是为了实验考察而添加的仅用于实验本身的 syscall 模块划分不完善，模块化程度不高，沿用框架开发到后期会比较痛苦 有经验的同学可以自行重构 rCore-Tutorial，或者重新写一个内核来参加OS比赛。但大多数只学过 rCore-Tutorial 的同学来说，这样的重构并不在它教程的范围内，因此修改 rCore-Tutorial 就成了参赛的一道门槛。 本教程的目的是帮助大家跨过这道门槛，能够将更多精力投入到内核本身的开发中。 实验形式 本教程中的实验参考 rCore-Tutorial，分为代码实验和思考题，每一章节需要提交报告。但也有以下不同： 整个教程没有统一的仓库，部分实验需要使用 rCore-Tutorial 仓库，部分实验自带另一个仓库。 实验参考了 rustlings 教程的形式，边做边学，跟随教程指引就可以完成大部分代码工作，而章节末尾的代码实验预期会需要更少的时间。 "},"docs/lab1/intro.html":{"url":"docs/lab1/intro.html","title":"实验概述","keywords":"","body":"运行裸机 C 程序 建议至少做完 rCore-Tutorial ch6 再做这个实验。 实验准备 你需要下载用于交叉编译的工具链：https://musl.cc/riscv64-linux-musl-cross.tgz，解压后将里面的 bin 目录放到你的 PATH 中，然后尝试使用以下命令 riscv64-linux-musl-gcc --version 来检查是否安装成功。 如果忘了怎么安装这类包，可以看rCore-Tutorial 指导书第0章环境配置中安装 Qemu 模拟器一节，操作是类似的。 实验概述 在往年的实验中，有些同学会有这样一种感受：整个 rCore-Tutorial 是一个完整的项目，从内核到测例到文件系统都是用 Rust 连接的，修改任何一部分都需要做额外的兼容。就像下面这样： 但其实这中间都是二进制接口，只是被实验仓库里完善的脚本掩盖了。我们可以任意更换这其中的每个部分，而不需要做另外的适配： graph LR; subgraph 任意用户程序 Rust代码--编译-->ELF文件 C代码--编译-->ELF文件 end subgraph 任意文件系统 ELF文件--放进-->easy-fs ELF文件--放进-->FAT32 end easy-fs-->块设备 FAT32-->块设备 subgraph 任意内核 块设备--挂载到-->rCore-Tutorial 块设备--挂载到-->其他内核 end 在本章中，我们将回顾用户程序的编译与加载流程，然后使用一个极简的 C 用户程序库代替 rCore-Tutorial 原有的 /user 测例，并修改上面这套编译、打包、加载的流程中的各个 Makefile，让我们的内核运行一个 C 语言的 helloworld。 "},"docs/lab1/toelf.html":{"url":"docs/lab1/toelf.html","title":"编译到二进制代码","keywords":"","body":"编译到二进制代码 在 ch6 中，rCore-Tutorial 指导书详细介绍了应用程序运行时如何读写文件、文件系统 easy-fs 的实现以及内核如何与文件系统交互。但对于用户程序如何在编译后被塞进文件系统这个过程，指导书讲得比较粗略，容易让大家以为用户程序和文件系统是以某种“魔法”联系在一起的。 现在我们先暂时跳出内核，破解这一层魔法。 在 user文件夹下，运行 make build CHAPTER=8 BASE=2 这一步会将所有 ch8 及之前的测例编译后放一份到 user/build/elf/ 中，然后将每个应用删除 ELF header 符号得到纯二进制的镜像，放到 user/build/bin/，如同 ch2 “实现应用程序”一节介绍的那样。但和 ch2 不同的是，这些ELF文件会被放到文件系统里，而不是直接链接进内核。 接下来在 user/build/elf/ 下运行 rust-objdump --arch-name=riscv64 -ld ch6_file0.elf > debug.S，可以在文件中看到像这样的输出 ch6_file0.elf: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 : ; _start(): 0: 0d 71 addi sp, sp, -352 2: 86 ee sd ra, 344(sp) 4: 2e fc sd a1, 56(sp) 6: aa e0 sd a0, 64(sp) 8: aa f5 sd a0, 232(sp) a: ae f9 sd a1, 240(sp) c: 97 00 00 00 auipc ra, 0 10: e7 80 20 5f jalr 1522(ra) ...... 这是一个 elf 格式的可执行文件。如果你看过 rCore-Tutorial 指导书的附录 B，就应该对这个形式有印象。这个测例的可执行文件与整个 OS 的可执行文件并没有什么不同。虽然我们用 Rust 编译了它，并且用 rust-objdump区查看它的反汇编，但到这一步这个文件已经和 Rust 无关了。我们可以尝试改用前面安装的交叉编译工具链，运行 riscv64-linux-musl-objdump -ld ch6_file0.elf > debug.S，可以在文件中看到这样的输出 ch6_file0.elf: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 : _start(): 0: 710d addi sp,sp,-352 2: ee86 sd ra,344(sp) 4: fc2e sd a1,56(sp) 6: e0aa sd a0,64(sp) 8: f5aa sd a0,232(sp) a: f9ae sd a1,240(sp) c: 00000097 auipc ra,0x0 10: 5f2080e7 jalr 1522(ra) # 5fe ...... 虽然排版上略有不同，且对函数调用地址给出了注释信息，但二进制文件本身是相同的。这意味着，我们可以用交叉编译工具链中的 gcc 编译一个 C 程序，把它塞到文件系统镜像里，它应该也能像 user 库里的 Rust 测例一样正常运行。不过这里还有一些细节问题，我们之后再讲这件事。 "},"docs/lab1/clib.html":{"url":"docs/lab1/clib.html","title":"测例库介绍","keywords":"","body":"测例库介绍 从这里可以获取到本次实验需要使用的用户程序。你需要把 testcases 目录放到当前实验（也就是 2023a-rcore- 开头的这个项目）的根目录下，在 testcases 目录下运行 make build 即可在 testcases/build/ 下获得 42 hello两个二进制文件。 测例里都有什么 这是一个极简的测例库，可以编译不依赖于 libc 的 C 程序。事实上，它对标的是比赛初赛测例库（ https://github.com/oscomp/testsuits-for-oskernel/tree/master/riscv-syscalls-testing ）的超级简化版。 你可以像上一节一样，在 build 目录下使用 riscv64-linux-musl-objdump -ld 42 > debug.S 检查这个可执行文件的内容。它非常短，只要你有一点点 RISC-V 汇编语言基础，都应该能读懂里面发生的每一件事（对照汇编看，这里就不粘一遍代码了）： _start 是整个程序的入口，它会将 sp 复制到 a0，相当于函数参数，然后调用 __start_main。这个参数并不直接等价于我们熟知的 argc 或argv，我们下面再详细介绍。 __start_main 是一个库提供的初始化函数。它初始化完成后，会调用 C 代码里用户程序自己的 main 函数。 main函数只是返回了一个 42，然后 __start_main 调用了 exit exit 其实相当于 sys_exit，也就是大家在 ch3 接触到的第一个 syscall，用于退出用户程序。在这段汇编中，它填好参数后会调用 __syscall1 最后 __syscall1 通过 ecall 陷入内核，通知内核这个用户程序结束了，且返回值是 42。ecall 后面的代码不会被执行到。 也可以直接看 C 的源代码。其中比较关键的是 lib\\main.c： int __start_main(long *p) { int argc = p[0]; char **argv = (void *)(p+1); exit(main(argc, argv)); return 0; } 其中输入参数 p 是 _start 调用 __start_main 时给的，实际上就是初始的用户栈指针。 main.c 中将初始用户栈指针 p 指向的值设为 argc，然后将 p+1 的值设为 argv。也就是说，用户栈上的空间大致是这样的 position content size (bytes) ------------------------------------------------------------------------ stack pointer -> [ argc = number of args ] 4 [ argv[0] (pointer) ] 4 (program name) [ argv[1] (pointer) ] 4 [ argv[..] (pointer) ] 4 * x [ argv[n - 1] (pointer) ] 4 [ argv[n] (pointer) ] 4 (= NULL) [ argv[0] ] >=0 (program name) [ '\\0' ] 1 [ argv[..] ] >=0 [ '\\0' ] 1 [ argv[n - 1] ] >=0 [ '\\0' ] 1 ------------------------------------------------------------------------ 注意从上到下是地址从低到高，而用户栈向低地址扩展。栈顶是 argc， 接下来是 argv 数组，它们依次指向每个真正的 argv[i] 字符串。 如果你还对 ch7 的命令行参数一节有印象，可能会很快发现，上面的栈排布和 ch7 指导书教的不太一样。事实上，上面的排布是符合 ELF 文件规范的（见 About ELF Auxiliary Vectors），而 rCore-Tutorial 指导书里的写法仅供学习参考。 为了支持原生的 Linux 应用，后续最好还是改用这里介绍的写法。 为什么使用这样一个测例项目 为什么我们要绕这么一个大弯，去手写一个测例库呢？你可能会想试试写一个最简单的 hello world： #include int main() { printf(\"hello world\"); } 然后用交叉编译器直接编译后看汇编，其实也没有多少行。但注意，这种方式生成出的可执行程序使用了动态链接，这是一项比赛复赛时才会涉及的功能，目前我们的内核是无法运行这样的程序的。例如你甚至无法在这段汇编中找到 ecall，这不是说这个用户程序不会执行 syscall，而只是它跳转到了外部的共享库中执行。如果感兴趣，你可以在搜索引擎搜索“动态链接”简单了解。 当然你也可以指定静态编译。假设上面的 hello world 是 a.c，使用 riscv64-linux-musl-gcc a.c -static 即可。这样得到的可执行文件不依赖外部库了，但有超过 5000 行，很难调试。你也可以在目前的内核中尝试运行它，看看是否会报错。 总之，使用标准库函数（如 printf ）的 C 用户程序不是这次实验要处理的问题。这就是为什么我们手写了一个测例库用于实验。 使用用户态 qemu 进行对拍 测例库里编译的测例都是完全符合规范的 RISC-V 可执行程序，所以它当然可以在其他内核上运行。 如果你还记得，在 rCore-Tutorial的 ch0配环境的时候，安装了 qemu-riscv64 和 qemu-system-riscv64。后者用于运行实验，而前者实际上是一个用户态模拟器。换而言之，它可以直接运行用户态的 RISC-V 程序，我们可以直接把测例文件扔给它。 例如在 testcases/ 目录下执行 qemu-riscv64 ./build/hello，就可以获取正确输出（你可以打开 testcases/src/hello.c 看看正确输出长什么样）。 同样地，也可以执行 qemu-riscv64 ./build/42。这个用户程序在退出时返回了一个 42，不过没有打印输出。但我们可以在上面的命令之后立即执行 echo $? 就可以看到返回值 42 $? 是一个shell的变量，表示上一条命令的返回值。 在这个例子中，具体来说是 qemu 的返回值。它执行了我们要求的用户程序，然后把用户程序的返回值作为自己的返回值，推给宿主机。 如此一来，后续我们每次遇到一个新的应用程序，就可以用 qemu-riscv64 进行检查，看看正常的“内核”运行它应该是什么样的，然后来推测我们的内核运行同一个测例时出了什么错。 我们把这种调试方式叫做“对拍”。 "},"docs/lab1/tofs.html":{"url":"docs/lab1/tofs.html","title":"打包进文件系统","keywords":"","body":"打包进文件系统 现在我们已经可以统一 Rust 和 C 的测例了，但现在的 rCore-Tutorial 只支持自动编译 并打包/user 下的测例，怎么把其他测例也放进 easy-fs 呢？ graph LR; /user里的Rust用户程序--编译-->ELF文件 其他用户程序--编译-->ELF文件 ELF文件--/user下的测例自动打包--->easy-fs ELF文件-.如何放进其他测例?.->easy-fs 在 ch6 中，我们知道 easy-fs-fuse 模块负责将用户程序打包成满足 easy-fs 格式的文件系统镜像。既然上面已经分析出 C 的应用和 Rust 的应用赛道文件系统镜像里没什么两样，现在我们就可以扩展这个模块，使得它可以生成同时包含 Rust 和 C 用户程序的镜像。（下面的说明只是其中一种做法，你可以用自己的方式完成这一步！） 其实，如果想要让内核支持 C 应用程序，可以一步到位，直接撇开原本的 user 库，只编译 C 的程序（比赛初赛的测例就完全没有 Rust 的用户程序）。 但由于本来的 rCore-Tutorial 实验已经包含了带 initproc 和 user_shell 的 Rust 用户程序，直接抛弃这些支持就会让调试过程重回 ch3/ch4 的状态，并且也难以利用已通过的大量 rCore 测例检查有没有改错东西，这对基础弱的同学不太友好。 因此，我们选择了折衷的方式进行讲解，让本实验中的内核可同时接收 C 和 Rust 的用户程序。 首先，我们来找找 easy-fs-fuse 是什么时候被调用的。 当在 os 文件夹下运行 make run时，文件系统镜像会自动生成。观察 os/Makefile文件，你可以发现 run 命令依赖于 build，build 命令依赖于 fs-img，这就是我们要找的命令了。 fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @rm -f $(FS_IMG) @cd ../easy-fs-fuse && cargo run --release -- -s ../user/src/bin/ -t ../user/target/riscv64gc-unknown-none-elf/release/ 回顾 ch6，最后这条命令的逻辑是，从 -s 后的目录 ../user/src/bin 中获取所有测例的名字，然后在 -t 后的目录 ../user/target/riscv64gc-unknown-none-elf/release/ 中依次找到对应的 ELF 文件，加入到文件系统镜像中。文件系统镜像最终会被放在 -t 后的目录（见 os/Makefile 开头 FS_IMG 的定义）。 这个 -s 有点啰嗦，我们只需要知道什么文件应该被打包，不需要知道它们的源文件是什么，况且之后要支持的 C 用户程序是不会有 Rust 的源文件的。由此可以修改一下这里 -s 和 -t 的语义： -s 之后的目录定义为要打包塞进文件系统镜像中的目录。 easy-fs-fuse 会依次寻找目录中的文件塞进文件系统镜像里。 -t之后的目录仅用来存放最终生成的文件系统镜像。 然后把命令重写成： FS_IMG := target/fs.img ...... fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @rm -f $(FS_IMG) @cd ../easy-fs-fuse && cargo run --release -- -s ../user/build/elf/ -t ../os/target/ 其中 FS_IMG 是 os/Makefile 开头定义的变量。按照新的语义，此时 fs-img 命令的逻辑就变成了“将 ../user/build/elf” 中的所有文件打包成文件系统镜像，放在 ../os/target/ 里。当然，还需要修改 easy-fs-fuse 使之满足新的语义： // easy-fs-fuse/src/main.rs let root_inode = Arc::new(EasyFileSystem::root_inode(&efs)); /* let apps: Vec = read_dir(src_path) .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); for app in apps { // load app data from host file system let mut host_file = File::open(format!(\"{}{}\", target_path, app)).unwrap(); let mut all_data: Vec = Vec::new(); host_file.read_to_end(&mut all_data).unwrap(); // create a file in easy-fs let inode = root_inode.create(app.as_str()).unwrap(); // write data to easy-fs inode.write_at(0, all_data.as_slice()); } */ for dir_entry in read_dir(src_path).unwrap().into_iter() { let dir_entry = dir_entry.unwrap(); let path = dir_entry.path(); let file_name = dir_entry.file_name().into_string().unwrap(); let base_name = &file_name[..file_name.rfind('.').unwrap_or(file_name.len())]; let mut host_file = File::open(&path).unwrap(); let mut all_data: Vec = Vec::new(); host_file.read_to_end(&mut all_data).unwrap(); // create a file in easy-fs let inode = root_inode.create(base_name).unwrap(); // write data to easy-fs inode.write_at(0, all_data.as_slice()); } 对比原本的代码（上面的注释）和修改后的新代码： src_path 目录原本被用来寻找所有源代码文件的名字，生成 apps 后再从 target_path中找对应的文件；修改后，代码通过 read_dir(src_path).unwrap().into_iter() 直接从 src_path 中去寻找文件塞进文件系统镜像里。 原本的代码中，通过 name_with_ext.find('.').unwrap() 找到每一个文件的后缀名，然后通过 name_with_ext.drain 删除，如果文件名中不包含 .，整个 easy-fs-fuse 就会报错。现在的代码通过 file_name.rfind('.') 寻找最后一个后缀名并删除，如果文件名中不包含 .，则会取文件全名。 当然，在现在的实现中，如果出现两个文件仅有后缀名不同的情况，会导致出错，不过这种检查也很容易实现。 可不可以不去除后缀名，直接原封不动把文件放到镜像里？ 可以，但比较麻烦。我们之所以一定要执着地去除后缀名，是因为可执行程序一般默认是无后缀的。如内核启动时首先会去找 initproc，这个用户程序又会去找 user_shell，而每一章的 usertest 也会去找每一个对应章节的测例。如果所有这些地方都考虑后缀，代码改起来就会很麻烦。不过，过渡到只是用 C 语言用户程序的初赛时，可以考虑把去后缀这一步删掉。 你还可以把这段修改下面的 for app in root_inode.ls() { println!(\"{}\", app); } 前的注释删掉以便观察最终被打包的文件有哪些。现在我们回到 os 目录，执行 fs-img CHAPTER=8 BASE=2 可以看到我们修改过的 easy-fs-fuse 正确打包了文件。 如何将 C 语言测例也包括进来呢？ 别忘了 C 的用户程序在 testcases里。我们像 user 那样也调用一次 make build 生成可执行文件，然后把两拨测例复制到一起，再交给 easy-fs-fuse 打包就可以了。现在我们再次修改 os/Makefile 中的 fs-img 命令如下 fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @make -C ../testcases build @rm -f $(FS_IMG) @cp ../user/build/elf/* ../testcases/build/ @cd ../easy-fs-fuse && cargo run --release -- -s ../testcases/build/ -t ../os/target/ 现在你可以同时打包 Rust 和 C 的用户程序了！ 再次在os 目录执行 fs-img CHAPTER=8 BASE=2，就可以唤出 usershell 了，现在你可以尝试运行本实验所使用的两个 C 语言用户程序了。 "},"docs/lab1/exercise.html":{"url":"docs/lab1/exercise.html","title":"练习","keywords":"","body":"练习 编程作业 完成 rCore-Tutorial 的同学可以从 ch8 开始修改。如果没有做到 ch8，也可以用全新的 ch7 来做实验。 在本实验中，你需要： 跟随前面文档的指引，扩展 easy-fs-fuse，使得它可以生成同时包含 Rust 和 C 用户程序的镜像 在 usershell 里运行了 42 和 hello 两个用户程序。42 的运行结果是符合预期的，但 hello 的结果看起来不太对，你的任务是修改内核，使得 hello 测例给出正常输出（即给出一行以 my name is 开头的输出，且 exit_code为0）。 问答作业 elf 文件和 bin 文件有什么区别？ Linux 的 file 命令可以检查文件的类型，尝试执行以下命令，描述你看到的现象，尝试解释输出 # 在 user/build/elf/ 下 file ch6_file0.elf # 在 user/build/bin/ 下 file ch6_file0.bin riscv64-linux-musl-objdump -ld ch6_file0.bin > debug.S 如果对应目录下没有文件，请在 user/ 目录执行 make build CHAPTER=8 BASE=2 报告要求 完成编程作业，描述你的思路以及修改的代码。本章没有自动评测，我们会人工检查你的代码实现和报告。 完成问答题。 推荐使用 markdown 格式 和 rCore-Tutorial 实验类似，报告放在 reports/文件夹下，但命名为 labr1.md或labr1.pdf "}}