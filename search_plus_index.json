{"./":{"url":"./","title":"实验简介","keywords":"","body":"从 rCore-Tutorial 到实际应用 在这里可以看到本项目的在线文档。 本教程是 rCore-Tutorial 的后续教程，希望能帮助大家从 rCore-Tutorial 以及其他 Rust 内核出发，构建一个可运行原生 Linux 应用、拥有更强大功能的内核。如果你是希望参加全国大学生计算机系统能力大赛操作系统设计赛的同学，可以通过本教程学习如何构建自己的内核；如果你是其他 Rust 开发者，也可以通过本教程扩展 rCore-Tutorial，用学到的知识为开源社区做贡献。 本教程的各个实验间不是连续的。我们会选择内核开发中的一些小切片，以它们为例设计代码量适中的实验，引导大家在OS比赛中的开发。如果说 rCore-Tutorial 是十层居民楼的毛坯房，需要大家通过 5 个实验去“装修”，那么本教程就像是一个个更高楼房的地基，指引大家从这里开始建造摩天大楼。 目前本教程被用作开源操作系统训练营（见 github 首页说明）的实践项目。 为什么会有这个教程？ rCore-Tutorial 是一个用 Rust 写操作系统的教程。当你做完这个教程，就已经获得了一个支持文件系统、线程等特性，包含约 50 个 syscall 的操作系统内核。 不过，如果想要进一步扩展这个内核，就会出现其他问题： rCore-Tutorial 的文件系统、测例自成一体，最后完成的内核也只能运行它自己的文件系统、跑自己的测例，和通用测例集乃至真正的 Linux 应用不兼容。 syscall 并不完全和 POSIX 接口兼容。部分 syscall 是来自 Zircon，还有一部分是为了实验考察而添加的仅用于实验本身的 syscall 模块划分不完善，模块化程度不高，沿用框架开发到后期会比较痛苦 有经验的同学可以自行重构 rCore-Tutorial，或者重新写一个内核来参加OS比赛。但大多数只学过 rCore-Tutorial 的同学来说，这样的重构并不在它教程的范围内，因此修改 rCore-Tutorial 就成了参赛的一道门槛。 本教程的目的是帮助大家跨过这道门槛，能够将更多精力投入到内核本身的开发中。 实验形式 本教程中的实验参考 rCore-Tutorial，分为代码实验和思考题，每一章节需要提交报告。但也有以下不同： 整个教程没有统一的仓库，部分实验需要使用 rCore-Tutorial 仓库，部分实验自带另一个仓库。 实验参考了 rustlings 教程的形式，边做边学，跟随教程指引就可以完成大部分代码工作，而章节末尾的代码实验预期会需要更少的时间。 "},"docs/lab1/intro.html":{"url":"docs/lab1/intro.html","title":"实验概述","keywords":"","body":"运行裸机 C 程序 建议先阅读 rCore-Tutorial ch6 及之前的内容再做这个实验。 rCore-Tutorial 有许多版本的指导书，详细的在这里，如果你没有太多时间，也可以阅读简略版本的指导书。 实验需要使用你在 rCore-Tutorial 实验中的仓库，但不依赖于你在 rCore-Tutorial 中完成的任何作业代码。你可以用自己的 rCore-Tutorial ch8 分支来做这个实验中的代码修改，也可以用没有修改过的 ch7 分支。 如果你还没有自己的 rCore-Tutorial 仓库，可以选择以下两种方式之一 通过邀请链接创建仓库： https://classroom.github.com/a/AFBsVzHi 进入这个仓库：https://github.com/LearningOS/rCore-Tutorial-Code-2023A/，在右上角点击绿色按钮 Use this template，然后点击 Create a new repository，这相当于 fork 了这个仓库到你的用户名下。 实验准备 本实验需要用到交叉编译的工具链：https://musl.cc/riscv64-linux-musl-cross.tgz。下载解压后将里面的 bin 目录放到你的 PATH 中，然后尝试使用以下命令 riscv64-linux-musl-gcc --version 来检查是否安装成功。 如果忘了怎么安装这类包，可以看rCore-Tutorial 指导书第0章环境配置中安装 Qemu 模拟器一节，操作是类似的。 实验概述 在往年的 rCore-Tutorial 实验中，有些同学会有这样一种感受：整个 rCore-Tutorial 是一个完整的项目，从内核到测例到文件系统都是用 Rust 连接的，修改任何一部分都需要做额外的兼容。就像下面这样： 但其实这中间都是二进制接口，只是被实验仓库里完善的脚本掩盖了。我们可以任意更换这其中的每个部分，而不需要做另外的适配： 在本章中，我们将回顾用户程序的编译与加载流程，然后使用一个极简的 C 用户程序库代替 rCore-Tutorial 原有的 /user 测例，并修改上面这套编译、打包、加载的流程中的各个 Makefile，让原本只支持 rCore-Tutorial 自带的 Rust 测例的内核运行一个从 C 语言编译的应用程序。 在实验之后 运行 C 用户程序是OS比赛初赛的第一步。如果你正在参赛或者准备参赛，那么在完成这个实验之后，还有下面这些工作要做 尝试通过比赛初赛测例库 比赛初赛测例库 可以直接访问，通过它也就通过了初赛。这个测例库比当前实验里要稍微复杂一些，但功能上相比 rCore-Tutorial 不会有太大变化。注意比赛的 syscall 规范和 rCore-Tutorial 的会有细微差别。 更换一个 FAT32 类型的文件系统 这是比赛初赛的要求。你可以自己写一个，也可以参考往年获奖作品的实现，也可以使用现有的开源项目，比如rust-fatfs。 FAT32 的好处在于，它是一个公共的文件系统格式。因此可以直接用 dd 和 mkfs.vfat 命令创建一个镜像（具体要求看比赛），然后直接在本地挂载它就可以往里塞文件了，完全不需要 easy-fs-fuse： # in makefile -mkdir temp sudo mount ./fs.img temp -sudo cp -r -a ./testcases/* ./temp/ sudo umount ./fs.img rmdir temp 这段命令把 fs.img挂载到 temp 文件夹中，然后把 testcases 里的所有测例都塞了进去，实际上和 easy-fs-fuse 做的事情是一样的。 顺便一提，- 开头的命令会如果执行失败，则 makefile 仍然继续进行下面的命令。 第一条指令的 - 是因为目录本身可能已存在，第三条指令的 - 开头是因为本地文件系统中可能有符号链接，它们在被复制进不支持链接的 FAT32 时会报错。无论如何，我们希望第三行指令执行完成后必须执行第四行指令 umount ./fs.img ，也就是取消 fs.img 的挂载。否则宿主机上可能会因为一次 make 失败而永远挂着这么一个文件系统。 考虑离线编译 截至目前，比赛的评测机不支持联网。因此，你可能需要为内核准备一个“离线”编译模式。具体来说，需要在内核 cargo build 的地方加上参数 --offline，然后在这个模式下将所有评测机不支持的依赖库拉到项目里。可以用 Makefile 变量等方式来控制这个参数。 如果本地网络不是很好的话，这种离线编译方式也许能为本地调试节省一些时间。毕竟，编译 Rust 项目时卡在拉取依赖库上实在是太常见了。 "},"docs/lab1/toelf.html":{"url":"docs/lab1/toelf.html","title":"编译到二进制代码","keywords":"","body":"编译到二进制文件 在 ch6 中，rCore-Tutorial 指导书详细介绍了应用程序运行时如何读写文件、文件系统 easy-fs 的实现以及内核如何与文件系统交互。但对于用户程序如何在编译后被塞进文件系统这个过程，指导书讲得比较粗略，容易让大家以为用户程序和文件系统是以某种“魔法”联系在一起的。 现在我们先暂时跳出内核，破解这一层魔法。 分析 user/Makefile 在 user文件夹下，运行 make build CHAPTER=8 BASE=2 这一步会将所有 ch8 及之前的测例编译后放一份到 user/build/elf/ 中，然后将每个应用删除 ELF header 符号得到纯二进制的镜像，放到 user/build/bin/，如同 ch2 “实现应用程序”一节介绍的那样。但和 ch2 不同的是，这些ELF文件会被放到文件系统里，而不是直接链接进内核。 我们可以看 user/Makefile 这个文件了解 make build 时发生了什么： ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS)) binary: @echo $(ELFS) @if [ ${CHAPTER} -gt 3 ]; then \\ cargo build $(MODE_ARG) ;\\ else \\ CHAPTER=$(CHAPTER) python3 build.py ;\\ fi @$(foreach elf, $(ELFS), \\ $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf)); \\ cp $(elf) $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.elf, $(elf));) ...... pre: @mkdir -p $(BUILD_DIR)/bin/ @mkdir -p $(BUILD_DIR)/elf/ @mkdir -p $(BUILD_DIR)/app/ @mkdir -p $(BUILD_DIR)/asm/ @$(foreach t, $(APPS), cp $(t) $(BUILD_DIR)/app/;) build: clean pre binary @$(foreach t, $(ELFS), cp $(t).bin $(BUILD_DIR)/bin/;) @$(foreach t, $(ELFS), cp $(t).elf $(BUILD_DIR)/elf/;) clean: @cargo clean @rm -rf $(BUILD_DIR) build: clean pre binary 告诉我们 build 这个任务依赖于后面的三个任务，所以只需要把这几个任务单独拉出来看： ELFS 定义了所有测例对应的 ELF 文件。patsubst 这个命令的意思是，把 $(APPS) 中每一个形如 $(APP_DIR)/%.rs 这样的字符串找出来，把它替换成 $(TARGET_DIR)/%（符号 % 对应前面 $(APP_DIR)/%.rs 那里的 % 表示的字符串），然后把所有替换后的串交给 ELFS。比如 src/bin/ch6_file0.rs 会被替换成 target/riscv64gc-unknown-none-elf/release/ch6_file0。 clean 删除了 cargo 也就是 Rust 编译后的临时文件，然后删除 build 目录 pre 创建了 build 目录以及下属的几个子目录，app elf bin 分别存放测例代码、测例编译后的 ELF 文件、ELF 文件删除元信息后的纯可执行文件。然后把代码复制一份，存到 app 目录下。 asm 下是空的，它会在另一个叫 disasm 的任务被用到 binary 首先用 if [ ${CHAPTER} -gt 3 ]; 检查编译的章节是否大于 3，大于 3 则使用 Rust 的编译器 cargo 编译，否则使用 python。随后，它会把 $(ELFS) 中所有文件的调试段删掉，命名为对饮的 .bin 文件。然后把 $(ELFS) 中所有文件复制一份，命名为对应的 .elf 文件。 如果你还记得的话，在 ch3 及之前我们的内核是“批处理操作系统”，所以需要依赖其他程序（代码框架里用的 python）做链接 最后 build 任务会把上一步 binary 生成的 .bin 和 .elf 文件分别复制一份到 $(BUILD_DIR)/bin/ 目录和 $(BUILD_DIR)/elf/ 目录。 检查二进制文件的内容 这一部分简要介绍编译生成的二进制文件的内容，更详细的信息可以参照 rCore-Tutorial 指导书的附录 B。 在 user/build/elf/ 下运行 rust-objdump --arch-name=riscv64 -ld ch6_file0.elf > debug.S，可以在文件中看到像这样的输出 ch6_file0.elf: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 : ; _start(): 0: 0d 71 addi sp, sp, -352 2: 86 ee sd ra, 344(sp) 4: 2e fc sd a1, 56(sp) 6: aa e0 sd a0, 64(sp) 8: aa f5 sd a0, 232(sp) a: ae f9 sd a1, 240(sp) c: 97 00 00 00 auipc ra, 0 10: e7 80 20 5f jalr 1522(ra) ...... 这是一个 elf 格式的可执行文件。如果你看过 rCore-Tutorial 指导书的附录 B 的话可能会对这个形式有印象。这个测例的可执行文件与整个 OS 的可执行文件并没有什么不同。例如你可以在文件中找到： _start 是整个程序的入口，也就是 os/src/task/process.rs 中调用 MemorySet::from_elf 拿到的 entry_point。 文件中的 ecall 指令实际上就是内核中看到的 syscall 调用的来源。在 ecall 指令之前通常在操作 a7 以及 a0 a1 a2 等寄存器，这就是内核在 os/src/trap/mod.rs:trap_handler 中看到的 let result = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12], cx.x[13]]); 所调用的几个寄存器。 下一节我们会详细带大家分析一个类似文件的内容。 虽然我们用 Rust 编译了它，并且用 rust-objdump区查看它的反汇编，但到这一步这个文件已经和 Rust 无关了。我们可以尝试改用前面安装的交叉编译工具链，运行 riscv64-linux-musl-objdump -ld ch6_file0.elf > debug.S，可以在文件中看到这样的输出 ch6_file0.elf: file format elf64-littleriscv Disassembly of section .text: 0000000000000000 : _start(): 0: 710d addi sp,sp,-352 2: ee86 sd ra,344(sp) 4: fc2e sd a1,56(sp) 6: e0aa sd a0,64(sp) 8: f5aa sd a0,232(sp) a: f9ae sd a1,240(sp) c: 00000097 auipc ra,0x0 10: 5f2080e7 jalr 1522(ra) # 5fe ...... 虽然排版上略有不同，且对函数调用地址给出了注释信息，但二进制文件本身是相同的。这意味着，我们可以用交叉编译工具链中的 gcc 编译一个 C 程序，把它塞到文件系统镜像里，它应该也能像 user 库里的 Rust 测例一样正常运行。不过这里还有一些细节问题，我们之后再讲这件事。 "},"docs/lab1/clib.html":{"url":"docs/lab1/clib.html","title":"测例库介绍","keywords":"","body":"测例库介绍 从这里可以获取到本次实验需要使用的用户程序。你需要把 lab1 分支下的 testcases 目录放到当前实验（也就是 2023a-rcore- 开头的这个项目）的根目录下，在 testcases 目录下运行 make build 即可在 testcases/build/ 下获得 42 hello两个二进制文件。 测例里都有什么 这是一个极简的测例库，可以编译不依赖于 libc 的 C 程序。事实上，它对标的是比赛初赛测例库（ https://github.com/oscomp/testsuits-for-oskernel/tree/master/riscv-syscalls-testing ）的超级简化版。 我们可以像上一节一样，在 build 目录下使用 riscv64-linux-musl-objdump -ld 42 > debug.S 检查这个可执行文件的内容。相对于其他汇编来说，其实它非常短，例如用标准库编译一个 hello world 有大概 5000 行。 其中的每一行，例如 100b0: 1141 addi sp,sp,-16 表示这一条指令的地址在 100b0，数值是 1141，这个数值的含义是一条 RISC-V 指令 addi sp,sp,-16。读懂里面发生的每一件事可能需要有一点 RISC-V 汇编语言基础，但不懂也没关系，我们会在代码下面解释它的内容： 42: file format elf64-littleriscv Disassembly of section .text: 00000000000100b0 : main(): 100b0: 1141 addi sp,sp,-16 100b2: e422 sd s0,8(sp) 100b4: 0800 addi s0,sp,16 100b6: 02a00793 li a5,42 100ba: 853e mv a0,a5 100bc: 6422 ld s0,8(sp) 100be: 0141 addi sp,sp,16 100c0: 8082 ret 00000000000100c2 : __start_main(): 100c2: 7179 addi sp,sp,-48 100c4: f406 sd ra,40(sp) 100c6: f022 sd s0,32(sp) 100c8: 1800 addi s0,sp,48 100ca: fca43c23 sd a0,-40(s0) 100ce: fd843783 ld a5,-40(s0) 100d2: 639c ld a5,0(a5) 100d4: fef42623 sw a5,-20(s0) 100d8: fd843783 ld a5,-40(s0) 100dc: 07a1 addi a5,a5,8 100de: fef43023 sd a5,-32(s0) 100e2: fec42783 lw a5,-20(s0) 100e6: fe043583 ld a1,-32(s0) 100ea: 853e mv a0,a5 100ec: fc5ff0ef jal ra,100b0 100f0: 87aa mv a5,a0 100f2: 853e mv a0,a5 100f4: 09c000ef jal ra,10190 00000000000100f8 : __syscall1(): 100f8: 1101 addi sp,sp,-32 100fa: ec22 sd s0,24(sp) 100fc: 1000 addi s0,sp,32 100fe: fea43423 sd a0,-24(s0) 10102: feb43023 sd a1,-32(s0) 10106: fe843883 ld a7,-24(s0) 1010a: fe043503 ld a0,-32(s0) 1010e: 00000073 ecall 10112: 87aa mv a5,a0 10114: 853e mv a0,a5 10116: 6462 ld s0,24(sp) 10118: 6105 addi sp,sp,32 1011a: 8082 ret ...... 0000000000010190 : exit(): 10190: 1101 addi sp,sp,-32 10192: ec06 sd ra,24(sp) 10194: e822 sd s0,16(sp) 10196: 1000 addi s0,sp,32 10198: 87aa mv a5,a0 1019a: fef42623 sw a5,-20(s0) 1019e: fec42783 lw a5,-20(s0) 101a2: 85be mv a1,a5 101a4: 05d00513 li a0,93 101a8: f51ff0ef jal ra,100f8 101ac: 0001 nop 101ae: 60e2 ld ra,24(sp) 101b0: 6442 ld s0,16(sp) 101b2: 6105 addi sp,sp,32 101b4: 8082 ret 00000000000101b6 : _start(): 101b6: 850a mv a0,sp 101b8: b729 j 100c2 _start 是整个程序的入口，它会将 sp 复制到 a0，相当于函数参数，然后调用 __start_main。这个参数并不直接等价于我们熟知的 argc 或argv，我们下面再详细介绍。 __start_main 是一个库提供的初始化函数。它初始化完成后，会调用 C 代码里用户程序自己的 main 函数。 main函数只是返回了一个 42，然后 __start_main 调用了 exit exit 其实相当于 sys_exit，也就是大家在 ch3 接触到的第一个 syscall，用于退出用户程序。在这段汇编中，它填好参数后会调用 __syscall1 最后 __syscall1 通过 ecall 陷入内核，通知内核这个用户程序结束了，且返回值是 42。ecall 后面的代码不会被执行到。 也可以直接看 C 的源代码。其中比较关键的是 lib\\main.c： int __start_main(long *p) { int argc = p[0]; char **argv = (void *)(p+1); exit(main(argc, argv)); return 0; } 其中输入参数 p 是 _start 调用 __start_main 时给的，实际上就是初始的用户栈指针。 main.c 中将初始用户栈指针 p 指向的值设为 argc，然后将 p+1 的值设为 argv。也就是说，用户栈上的空间大致是这样的 position content size (bytes) ------------------------------------------------------------------------ stack pointer -> [ argc = number of args ] 8 [ argv[0] (pointer) ] 8 (program name) [ argv[1] (pointer) ] 8 [ argv[..] (pointer) ] 8 * x [ argv[n - 1] (pointer) ] 8 [ argv[n] (pointer) ] 8 (= NULL) [ argv[0] ] >=0 (program name) [ '\\0' ] 1 [ argv[..] ] >=0 [ '\\0' ] 1 [ argv[n - 1] ] >=0 [ '\\0' ] 1 ------------------------------------------------------------------------ 注意从上到下是地址从低到高，而用户栈向低地址扩展。栈顶是 argc， 接下来是 argv 数组，它们依次指向每个真正的 argv[i] 字符串。 如果还对 ch7 的命令行参数一节有印象，可能很快就会发现，上面的栈排布和 ch7 指导书教的不太一样。事实上，上面的排布是符合 ELF 文件规范的（见 About ELF Auxiliary Vectors，网页中的 4 在我们这里换成了 8，因为目标架构 riscvgc64 是 64 位），而 rCore-Tutorial 指导书里的写法只能仅供学习参考。 为了支持原生的 Linux 应用，后续最好还是改用这里介绍的写法。 为什么使用这样一个测例项目 为什么我们要绕这么一个大弯，去手写一个测例库呢？你可能会想试试写一个最简单的 hello world： #include int main() { printf(\"hello world\"); } 然后用交叉编译器直接编译后看汇编，其实也没有多少行。但注意，这种方式生成出的可执行程序使用了动态链接，这是一项比赛复赛时才会涉及的功能，目前我们的内核是无法运行这样的程序的。例如在这段汇编中甚至无法找到一个 ecall，这不是说这个用户程序不会执行 syscall，而只是它跳转到了外部的共享库中执行。如果感兴趣，可以在搜索引擎搜索“动态链接”简单了解。 当然也可以指定静态编译。假设上面的 hello world 是 a.c，使用 riscv64-linux-musl-gcc a.c -static 即可。这样得到的可执行文件不依赖外部库了，但有超过 5000 行，很难调试。你也可以在目前的内核中尝试运行它，看看是否会报错。 总之，使用标准库函数（如 printf ）的 C 用户程序不是这次实验要处理的问题。这就是为什么我们手写了一个测例库用于实验。 调试技巧：使用用户态 qemu 进行对拍 测例库里编译的测例都是完全符合规范的 RISC-V 可执行程序，所以它当然可以在其他内核上运行。 如果你还记得，在 rCore-Tutorial的 ch0 配环境的时候，安装了 qemu-riscv64 和 qemu-system-riscv64。后者用于运行实验，而前者实际上是一个用户态模拟器。换而言之，它可以直接运行用户态的 RISC-V 程序，我们可以直接把测例文件扔给它。 例如在 testcases/ 目录下执行 qemu-riscv64 ./build/hello，就可以获取正确输出（可以打开 testcases/src/hello.c 看看正确输出长什么样）。 同样地，也可以执行 qemu-riscv64 ./build/42。这个用户程序在退出时返回了一个 42，不过没有打印输出。但我们可以在上面的命令之后立即执行 echo $? 就可以看到返回值 42 $? 是一个shell的变量，表示上一条命令的返回值。 在这个例子中，具体来说是 qemu 的返回值。它执行了我们要求的用户程序，然后把用户程序的返回值作为自己的返回值，推给宿主机。 如此一来，后续我们每次遇到一个新的应用程序，就可以用 qemu-riscv64 进行检查，看看正常的“内核”运行它应该是什么样的，然后来推测我们的内核运行同一个测例时出了什么错。 我们把这种调试方式叫做“对拍”。 "},"docs/lab1/tofs.html":{"url":"docs/lab1/tofs.html","title":"打包进文件系统","keywords":"","body":"打包进文件系统 现在我们已经可以统一 Rust 和 C 的测例了，但现在的 rCore-Tutorial 只支持自动编译 并打包/user 下的测例，怎么把其他测例也放进 easy-fs 呢？ graph LR; /user里的Rust用户程序--编译-->ELF文件 其他用户程序--编译-->ELF文件 ELF文件--/user下的测例自动打包--->easy-fs ELF文件-.如何放进其他测例?.->easy-fs 在 ch6 中，我们知道 easy-fs-fuse 模块负责将用户程序打包成满足 easy-fs 格式的文件系统镜像。既然上面已经分析出 C 的应用和 Rust 的应用赛道文件系统镜像里没什么两样，现在我们就可以扩展这个模块，使得它可以生成同时包含 Rust 和 C 用户程序的镜像。（下面的说明只是其中一种做法，你可以用自己的方式完成这一步！） 其实，如果想要让内核支持 C 应用程序，可以一步到位，直接撇开原本的 user 库，只编译 C 的程序（比赛初赛的测例就完全没有 Rust 的用户程序）。 但由于本来的 rCore-Tutorial 实验已经包含了带 initproc 和 user_shell 的 Rust 用户程序，直接抛弃这些支持就会让调试过程重回 ch3/ch4 的状态，并且也难以利用已通过的大量 rCore 测例检查有没有改错东西，这对基础弱的同学不太友好。 因此，我们选择了折衷的方式进行讲解，让本实验中的内核可同时接收 C 和 Rust 的用户程序。 首先，我们来找找 easy-fs-fuse 是什么时候被调用的。 当在 os 文件夹下运行 make run时，文件系统镜像会自动生成。观察 os/Makefile文件，可以发现 run 命令依赖于 build，build 命令依赖于 fs-img，这就是我们要找的命令了。 fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @rm -f $(FS_IMG) @cd ../easy-fs-fuse && cargo run --release -- -s ../user/src/bin/ -t ../user/target/riscv64gc-unknown-none-elf/release/ 回顾 ch6，最后这条命令的逻辑是，从 -s 后的目录 ../user/src/bin 中获取所有测例的名字，然后在 -t 后的目录 ../user/target/riscv64gc-unknown-none-elf/release/ 中依次找到对应的 ELF 文件，加入到文件系统镜像中。文件系统镜像最终会被放在 -t 后的目录（见 os/Makefile 开头 FS_IMG 的定义）。 这个 -s 有点啰嗦，我们只需要知道什么文件应该被打包，不需要知道它们的源文件是什么，况且之后要支持的 C 用户程序是不会有 Rust 的源文件的。由此可以修改一下这里 -s 和 -t 的语义： -s 之后的目录定义为要打包塞进文件系统镜像中的目录。 easy-fs-fuse 会依次寻找目录中的文件塞进文件系统镜像里。 -t之后的目录仅用来存放最终生成的文件系统镜像。 然后把命令重写成： FS_IMG := target/fs.img ...... fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @rm -f $(FS_IMG) @cd ../easy-fs-fuse && cargo run --release -- -s ../user/build/elf/ -t ../os/target/ 其中 FS_IMG 是 os/Makefile 开头定义的变量。按照新的语义，此时 fs-img 命令的逻辑就变成了“将 ../user/build/elf” 中的所有文件打包成文件系统镜像，放在 ../os/target/ 里。当然，还需要修改 easy-fs-fuse 使之满足新的语义： // easy-fs-fuse/src/main.rs let root_inode = Arc::new(EasyFileSystem::root_inode(&efs)); /* let apps: Vec = read_dir(src_path) .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len()); name_with_ext }) .collect(); for app in apps { // load app data from host file system let mut host_file = File::open(format!(\"{}{}\", target_path, app)).unwrap(); let mut all_data: Vec = Vec::new(); host_file.read_to_end(&mut all_data).unwrap(); // create a file in easy-fs let inode = root_inode.create(app.as_str()).unwrap(); // write data to easy-fs inode.write_at(0, all_data.as_slice()); } */ for dir_entry in read_dir(src_path).unwrap().into_iter() { let dir_entry = dir_entry.unwrap(); let path = dir_entry.path(); let file_name = dir_entry.file_name().into_string().unwrap(); let base_name = &file_name[..file_name.rfind('.').unwrap_or(file_name.len())]; let mut host_file = File::open(&path).unwrap(); let mut all_data: Vec = Vec::new(); host_file.read_to_end(&mut all_data).unwrap(); // create a file in easy-fs let inode = root_inode.create(base_name).unwrap(); // write data to easy-fs inode.write_at(0, all_data.as_slice()); } 对比原本的代码（上面的注释）和修改后的新代码： src_path 目录原本被用来寻找所有源代码文件的名字，生成 apps 后再从 target_path中找对应的文件；修改后，代码通过 read_dir(src_path).unwrap().into_iter() 直接从 src_path 中去寻找文件塞进文件系统镜像里。 原本的代码中，通过 name_with_ext.find('.').unwrap() 找到每一个文件的后缀名，然后通过 name_with_ext.drain 删除，如果文件名中不包含 .，整个 easy-fs-fuse 就会报错。现在的代码通过 file_name.rfind('.') 寻找最后一个后缀名并删除，如果文件名中不包含 .，则会取文件全名。 当然，在现在的实现中，如果出现两个文件仅有后缀名不同的情况，会导致出错，不过这种检查也很容易实现。 可不可以不去除后缀名，直接原封不动把文件放到镜像里？ 可以，但比较麻烦。我们之所以一定要执着地去除后缀名，是因为可执行程序一般默认是无后缀的。如内核启动时首先会去找 initproc，这个用户程序又会去找 user_shell，而每一章的 usertest 也会去找每一个对应章节的测例。如果所有这些地方都考虑后缀，代码改起来就会很麻烦。不过，过渡到只是用 C 语言用户程序的初赛时，可以考虑把去后缀这一步删掉。 还可以把这段修改下面的几行代码 for app in root_inode.ls() { println!(\"{}\", app); } 前的注释删掉以便观察最终被打包的文件有哪些。现在我们回到 os 目录，执行 fs-img CHAPTER=8 BASE=2 可以看到我们修改过的 easy-fs-fuse 正确打包了文件。 如何将 C 语言测例也包括进来呢？ 别忘了 C 的用户程序在 testcases里。我们像 user 那样也调用一次 make build 生成可执行文件，然后把两拨测例复制到一起，再交给 easy-fs-fuse 打包就可以了。现在我们再次修改 os/Makefile 中的 fs-img 命令如下 fs-img: $(APPS) @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @make -C ../testcases build @rm -f $(FS_IMG) @cp ../user/build/elf/* ../testcases/build/ @cd ../easy-fs-fuse && cargo run --release -- -s ../testcases/build/ -t ../os/target/ 现在我们可以同时打包 Rust 和 C 的用户程序了！ 再次在os 目录执行 fs-img CHAPTER=8 BASE=2，就可以唤出 usershell 了，现在你可以尝试运行本实验所使用的两个 C 语言用户程序了。 "},"docs/lab1/boot.html":{"url":"docs/lab1/boot.html","title":"扩展阅读：RISC-V 架构与内核启动","keywords":"","body":"扩展阅读：RISC-V 架构与内核启动 其实 rCore-Tutorial 指导书第一章 已经对 rCore-Tutorial 的内核启动过程做了大致描述，我们仅在此简要描述流程，并且补充必要的内容。全国大学生计算机系统能力大赛操作系统设计赛 内核赛道要求采用 RISC-V 架构，所以我们在这里会简单解释 RISC-V 的内容。如果你希望开发 x86_64 或者 arm 的内核，可以参考支持这项架构的内核。例如 Arceos 是一个支持上述这些架构的内核，感兴趣的同学可以去看看它的启动过程。 RISC-V 特权级 在 RISC-V 架构上有不同的特权级（priviledge level），每个特权级有不同的权限。在没有虚拟化的场景下，权限从高到低分别是 Machine 模式（或称 M 态）。这个模式可以访问所有资源，拥有所有权限。默认情况下，所有的异常中断处理都是在 M 态进行的，只有通过它的“允许”（修改一些只有 M 态才能访问的寄存器），部分的异常中断才能被委托给操作系统处理 Supervisor 模式（或称 S 态）。操作系统内核通常运行操作系统内核，内核需要 M 态的程序为它准备一些执行环境，也可以调用 M 态的程序完成一些任务。例如 rCore-Tutorial 中内核向串口输出就是向运行在 M 态的 Rustsbi 发送 sbicall 请求实现的。 User 模式（或称 U 态），一般用于执行真正的用户程序，权限最低。U 态的程序一般不能访问任何硬件资源，只能通过调用 syscall 请求 S 态的操作系统处理。当然，也有许多研究通过让 U 态的用户程序直接处理硬件驱动的方式来提高执行效率，那就是另一个故事了。 高权限的模式可以访问低权限模式的一切信息，并控制地权限模式的执行流程。系统启动流程也是从高权限模式开始，初始化完成后再启动低特权级的模式。 有虚拟化的情况下，还会有类似 S 态的 hypervisor 模式（HS 态），和 S 态权限一致，但它可以作为一个虚拟的 M 态，在上面支持多个操作系统，是一种“虚拟机”。在 HS 态之上的虚拟操作系统运行在 VS 态，在这样的操作系统上运行的用户程序运行在 VU 态。本课程不涉及虚拟化的知识，如果同学对这一部分内容感兴趣，可以在 LearnOS 课程首页 寻找 RVM 相关内容学习，例如 RVM-Tutorial 每台 RISC-V 机器并不一定需要具有所有的特权级。例如在嵌入式设备上只需要 M 态，所有的程序都直接运行在 M 态。我们这个课程讲的是操作系统，在运行时通常包含 M/S/U 三个特权级。 Qemu 启动 Qemu 是一个模拟器，为了不把大家绕晕，这里不具体介绍 Qemu 的实现了，只需要假设 Qemu 启动后我们就有了一台 RISC-V 架构的机器就行。通过 os/Makefile 里给 Qemu 的启动参数，可以了解到我们这台“机器”都有什么： 不要在终端里输入下面的代码，它不是用来直接执行的，而是写在 Makefile 里的 qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) 其中 -bios 制定了一个 BootLoader，它是运行在 M 态的程序，负责初始化以及启动内核，默认加载到内存中 0x80000000 这个地址。默认情况下， Qemu 会使用 OpenSBI 启动，但 rCore-Tutorial 在这里指定了使用 RustSBI 启动（ $(BOOTLOADER) 这个常量的值见 os/Makefile 开头处），它是首个使用 Rust 编写的 SBI 实现。 -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) 指定了内核加载的位置是 KERNEL_ENTRY_PA，即 0x80200000，内核镜像会被放置在内存的这个位置。 启动过程 在内核启动时，经历了以下步骤： CPU 从物理地址 0x1000 开始执行一段硬件（在我们的实验中是 Qemu 模拟出的）上的引导代码，此时 CPU 位于 M 态。 CPU 跳转到 0x80000000 执行 RustSBI 的初始化代码，此时 CPU 位于 M 态。之后通过 mret 跳转到 0x80200000 执行内核的第一条代码，同时 CPU 切换到 S 态。 其实内核中也有一条类似的指令，就是 os/src/trap/trap.S 中的 sret，它会在跳转的同时从 S 态切换到 U 态。 0x80200000 这个地址是直接编码在 SBI 里的，不需要 Qemu 告诉它内核在哪。 内核的第一条代码是位于 os/src/entry.asm 中的 _start 符号所在的位置。这个文件包含以下内容 .section .text.entry .globl _start _start: la sp, boot_stack_top call rust_main .section .bss.stack .globl boot_stack_lower_bound boot_stack_lower_bound: .space 4096 * 16 .globl boot_stack_top boot_stack_top: 它在 .bss 段预留了 16*4K 的空间作为启动栈。内核启动后，首先通过 la sp, boot_stack_top 将这个启动栈的位置写入 sp 寄存器，然后通过 call rust_main 跳转到 os/src/main.rs:rust_main 执行。这是因为高级语言里函数调用需要使用栈帧，所以需要在最开始的汇编代码中初始化 sp。 随后就是 Rust 代码控制的启动流程了： pub fn rust_main() -> ! { clear_bss(); println!(\"[kernel] Hello, world!\"); logging::init(); mm::init(); mm::remap_test(); trap::init(); trap::enable_timer_interrupt(); timer::set_next_trigger(); fs::list_apps(); task::add_initproc(); task::run_tasks(); panic!(\"Unreachable in rust_main!\"); } 这些函数实际上包含了以下启动的步骤： clear_bss 把 .bss 段清零，这里通常存放的是全局变量。 logging::init() 初始化了日志，之后就可以使用 error! info! 等进行输出了，而不只是 println! mm::init() 初始化了内核堆、页帧分配器和内核页表。内核堆初始化后，可以使用 Vec 等动态大小的结构；页帧分配器初始化后，可以给页表分配页面；内核页表初始化后，可以给内核各段限制权限了，例如代码段 .text 是只读的，但在此之前可以任意修改内核中任意地址处的值。 trap::init() 初始化了异常中断处理过程。如果在此之前发生异常、中断，会直接由 M 态处理，通常会直接导致内核退出。 trap::enable_timer_interrupt() 和 timer::set_next_trigger() 开启了时钟中断，此后每隔一段时间，异常中断处理模块 os/src/trap/ 就会收到一次时钟中断。不过目前的 rCore-Tutorial 在内核态时会屏蔽中断，因此只有通过 sret 进入用户态后它才会触发。 fs::list_apps() task::add_initproc() 访问文件系统并将用户程序加载到内核 task::run_tasks() 开始进入第一个用户程序并执行 "},"docs/lab1/exercise.html":{"url":"docs/lab1/exercise.html","title":"练习","keywords":"","body":"练习 编程作业 完成 rCore-Tutorial 的同学可以从 ch8 开始修改。如果没有做到 ch8，也可以用全新的 ch7 来做实验。 在本实验中，你需要： 跟随前面文档的指引，扩展 easy-fs-fuse，使得它可以生成同时包含 Rust 和 C 用户程序的镜像 在 usershell 里运行了 42 和 hello 两个用户程序。42 的运行结果是符合预期的，但 hello 的结果看起来不太对，你的任务是修改内核，使得 hello 测例给出正常输出（即给出一行以 my name is 开头的输出，且 exit_code为0）。 问答作业 elf 文件和 bin 文件有什么区别？ Linux 的 file 命令可以检查文件的类型，尝试执行以下命令，描述看到的现象，然后尝试解释输出 # 在 user/build/elf/ 下 file ch6_file0.elf # 在 user/build/bin/ 下 file ch6_file0.bin riscv64-linux-musl-objdump -ld ch6_file0.bin > debug.S 如果对应目录下没有文件，请在 user/ 目录执行 make build CHAPTER=8 BASE=2 报告要求 完成编程作业，描述实现思路以及修改的代码。本章没有自动评测，我们会人工检查你的代码实现和报告。 完成问答题。 推荐使用 markdown 格式 和 rCore-Tutorial 实验类似，报告放在 reports/文件夹下，但命名为 labr1.md或labr1.pdf "},"docs/lab2/intro.html":{"url":"docs/lab2/intro.html","title":"实验概述","keywords":"","body":"运行带标准库的 C 程序 建议至少做完本指导书的 lab1 再做这个实验。 实验需要使用你在 rCore-Tutorial 实验中的仓库，但不依赖于你在 rCore-Tutorial 中完成的任何作业代码。你可以用自己的 rCore-Tutorial ch8 分支来做这个实验中的代码修改，也可以用没有修改过的 ch7 分支。 实验准备 从这里获取本次实验需要使用的用户程序。你需要把 lab2 分支下的 testcases 目录放到当前实验（也就是 2023a-rcore- 开头的这个项目）的根目录下，在 testcases 目录下运行 make build 即可在 testcases/build/ 下获得 42 hello hellostd 三个二进制文件。 本次实验中我们只使用 hellostd 这个测例。 实验概述 在上一个实验的为什么使用这样一个测例项目 这一小节中，我们尝试直接交叉编译一个 hello world： #include int main() { printf(\"hello world\"); } 发现内核无法运行这个程序，并且反汇编的结果太长，似乎完全无法调试。 在这次实验中，我们会一步步尝试分析这个测例的报错情况，继续修改内核，使得内核可以成功运行一个带标准库的 hello world。 这一章的文档可能在某种程度上更像一个“debug 记录”。指导书里会把难处理的地方都讲一遍，最后留一个比较简单的小实验作为作业。你可以直接跳到最后一节去完成实验内容，但我们更希望大家可以跟着指导书走一遍调试过程，学习途中的调试思路。 在实验中你可以学到： 若干种常用调试方法：全局搜素、LOG输出、反汇编、GDB调试 如何引入其他内核的代码来完成实验 阅读标准 Linux syscall 规范，并按照它实现 syscall 的方法 rCore-Tutorial 和 Linux syscall 规范的区别 在实验之后 你可以以本实验为基础，完成比赛决赛第一阶段要求的 libc-test，测例见这里。这个测例集分两个部分，分别是静态链接的测例（gcc 编译加 -static选项）和动态链接的测例。 支持 libc-test 中的静态链接测例 支持静态链接测例的思路和实验类似。但所有测例本身都会用到 runtest.exe，它的源代码中包含了许多复杂的 syscall。 你可以使用本实验中的分析方法想办法跳过它们，也可以尝试使用这里提到的思路，逐个击破一些小测例，最后再使用 runtest.exe 运行。 支持 libc-test 中的动态链接测例 支持动态链接测例时，需要内核在ELF加载器中主动添入GOT表和PLT表项。如果觉得太难，也可以直接参考从往届代码的实现，比如本实验引用的这个内核 就在 kernel/src/loaders/mod.rs 模块中带了动态链接的实现。 "},"docs/lab2/pos.html":{"url":"docs/lab2/pos.html","title":"三种调试方法","keywords":"","body":"寻找报错位置 在这一小节中，我们会尝试分析 hellostd 测例的报错情况，并介绍三种常见的内核调试技巧。巧合的是，我们的调试过程恰好会用到每一项技巧，因此你可以跟着指导书走一遍整个流程以熟悉它们，而不只是枯燥地听课看文档。 调试技巧：全局搜索输出 按照上一节的实验准备下载好测例后，我们来尝试在目前的内核中运行 hellostd 这个测例。在 os/ 目录下 make run，然后在弹出的终端中输入 hellostd，大概率会得到下面这样一行错误输出： Rust user shell >> hellostd Shell: Process 2 exited with code -11 如果运行结果是 exited with code -4 而不是 -11，说明你在上一个实验中的实现碰巧“跳过”了这一个 bug。此时可以阅览一下本节的内容，然后下一节再跟着做 显然，这个测例运行失败了，但是是在哪里失败的呢？我们可以尝试全局搜索一下这一行是在哪里输出的。首先，2 和 -11 看上去不像是直接写在代码里的内容，我们要找的应该是 Shell: Process 和 exited with code 这两段文本，且它们中间隔着一些其他字符。所以可以把要搜索的表达式写成 Shell: Process .* exited with code 注意，不要想当然认为中间要搜的部分是 [0-9] 的数字。它们应该是任意匹配的字符。 因为要搜索的是“代码”而不是同样格式的“输出”，所以很可能我们要找的内容类似下面几种形式之一： println!(\"Shell: Process {} exited with code {}\", id, code); println!(\"Shell: Process {id} exited with code {code}\"); printf(\"Shell: Process %d exited with code %d\", id, code); 它们中间对应 2 和 -11 的部分都不是数字。 然后我们就可以使用如下命令搜索可能的输出位置。 grep -rn \"Shell: Process .* exited with code\" ./src 其中，-r 表示递归搜索下面的目录，-n 表示找到字符串时输出对应行号。而 ./src 是我们要搜索的目录，因为现在在 os/ 下，所以实际搜索的是 os/src/ 下的内容，也就是内核的代码。 不出意外的话，上面这条命令不会给出任何输出，这说明内核代码里没有这样的语句。不过，这一行也可能是用户程序输出的，我们在用户测例的代码目录再试一次： grep -rn \"Shell: Process .* exited with code\" ../user/src 这次我们找到了输出的具体位置，是其中一个 user_shell，即终端程序。具体是哪一个取决于你正在运行本实验的分支。 ../user/src/bin/ch8b_user_shell.rs:193: //println!(\"Shell: Process {} exited with code {}\", pid, exit_code); ../user/src/bin/ch7b_user_shell.rs:107: println!(\"Shell: Process {} exited with code {}\", pid, exit_code); ../user/src/bin/ch6b_user_shell.rs:43: println!(\"Shell: Process {} exited with code {}\", pid, exit_code); ../user/src/bin/ch5b_user_shell.rs:43: println!(\"Shell: Process {} exited with code {}\", pid, exit_code); VSCODE 的全局搜索 如果你在使用带 GUI 的 IDE 编程，也可以完全不用记上面的命令。例如 VSCODE 就带有一个搜索器。 以 VSCODE 为例，简单介绍一下这个工具的用法： 如图所示，你可以在窗口左侧找到搜索功能（标点1），然后在第一个框内输入要搜索的字符串。 如果字符串中包含正则匹配相关的内容，可以打开右侧的正则表达式开关（标点2）。顺便一提，前两个开关分别是区分大小写和全词匹配（即不允许匹配半个词，两边必须是空格或符号） 这个搜索的范围默认是这个窗口打开的目录。如果想在指定目录下搜索，或者去除某些目录的搜索结果，可以点开右下角的按钮（标点3），然后输出搜索目录。 你可以直接点击搜索结果跳转到对应的文件，不需要手动翻找目录去打开文件。 调试技巧：别忘了 LOG 输出 找到了输出位置，我们来看看 user_shell 为什么会告诉我们 Shell: Process 2 exited with code -11。先阅览一下 ch7b_user_shell.rs 在这条输出附近的代码： if pid == 0 { // input redirection if !input.is_empty() { let input_fd = open(input.as_str(), OpenFlags::RDONLY); if input_fd == -1 { println!(\"Error when opening file {}\", input); return -4; } let input_fd = input_fd as usize; close(0); assert_eq!(dup(input_fd), 0); close(input_fd); } // output redirection if !output.is_empty() { let output_fd = open(output.as_str(), OpenFlags::CREATE | OpenFlags::WRONLY); if output_fd == -1 { println!(\"Error when opening file {}\", output); return -4; } let output_fd = output_fd as usize; close(1); assert_eq!(dup(output_fd), 1); close(output_fd); } // child process if exec(args_copy[0].as_str(), args_addr.as_slice()) == -1 { println!(\"Error when executing!\"); return -4; } unreachable!(); } else { let mut exit_code: i32 = 0; let exit_pid = waitpid(pid as usize, &mut exit_code); assert_eq!(pid, exit_pid); println!(\"Shell: Process {} exited with code {}\", pid, exit_code); } 可以看到，这个程序执行失败并不是因为打开文件失败或者 exec 函数失败，而是 user_shell 在 waitpid 等待它执行完成的时候，得知了程序返回 -11 的消息。这说明它很可能已经正常进入用户态了，是运行途中出现的问题。 那么，-11 是哪来的呢？如果是用户程序自己 exit 时传入的参数 -11，那么我们可能得另找办法了。不过幸运的是，我们直接在内核代码中搜索 -11 就能找到它的来源： grep -rn \"\\-11\" ./src ./src/task/context.rs:11: /// s0-11 register, callee saved ./src/task/signal.rs:33: Some((-11, \"Segmentation Fault, SIGSEGV=11\")) 如果不加反斜杠 \\，grep 会把 - 理解成正则表达式里的负号。而加了反斜杠以后， \\- 才表示我们真的想搜索这个负号。你可以试一试去掉反斜杠 \\ 会搜出什么结果。 所以有搜索 GUI 的情况下还是用 GUI 比较方便。 来自 signal.rs 的代码告诉我们，-11 可能来自一个段错误，继续搜索 SIGSEGV 就能找到触发的位置： /// at os/src/trap/mod.rs #[no_mangle] pub fn trap_handler() -> ! { set_kernel_trap_entry(); let scause = scause::read(); let stval = stval::read(); // trace!(\"into {:?}\", scause.cause()); match scause.cause() { Trap::Exception(Exception::UserEnvCall) => { // jump to next instruction anyway let mut cx = current_trap_cx(); cx.sepc += 4; // get system call return value let result = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12], cx.x[13]]); // cx is changed during sys_exec, so we have to call it again cx = current_trap_cx(); cx.x[10] = result as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) | Trap::Exception(Exception::InstructionFault) | Trap::Exception(Exception::InstructionPageFault) | Trap::Exception(Exception::LoadFault) | Trap::Exception(Exception::LoadPageFault) => { error!( \"[kernel] trap_handler: {:?} in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", scause.cause(), stval, current_trap_cx().sepc, ); current_add_signal(SignalFlags::SIGSEGV); } 这个测例是不是触发了 Exception::LoadPageFault？注意到 SISEGV 前有 error 输出，我们只需要使用 make run LOG=ERROR 就可以看到所有 ERROR 级别以上的内核输出了。其实在 rCore-Tutorial ch3 的问答作业中就提到过 LOG 功能的用法，甚至于在 ch1 和 ch2 中还尝试了使用 log 输出五颜六色的调试语句，不过可能大部分同学已经忘了还有这一层调试工具。 现在我们在 os/ 目录下执行 make run LOG=ERROR，然后在弹出的终端中输入 hellostd，你会得到如下所示的输出 >> hellostd [ERROR] [kernel] trap_handler: Exception(LoadPageFault) in application, bad addr = 0xb000, bad instruction = 0x572, kernel killed it. Shell: Process 2 exited with code -11 虽然报错的地址可能略有不同（取决于你在上一个实验中的代码实现），但我们终于可以确认，测例 hellostd 运行失败就是由于触发 LoadPageFault 访问了错误的地址。 LOG 输出的注意事项 总的来说，我们建议在每次出 bug 时首先打开 LOG 输出再运行，也就是 make run LOG=ERROR 或者更低的 LOG 等级，比如 make run LOG=TRACE。但使用 LOG 也会有一些需要注意的地方： LOG 只会输出我们预先埋在代码中的 error! warn! trace! 等等这些语句，换句话说，它只能检查到我们预期可能会出 bug 的点。但问题也可能出现在我们没有预料到的地方，所以调试过程中很可能还需要新加 LOG 语句。 在运行特定测例时，一些代码执行的频率过高，在其中插入 LOG 语句时要再三考虑。比如 user_shell 中每输出一个字符就会调用一次 sys_read，再比如有些应用会反复调用 sys_clock_get_time 来更新自身的时间，如果在这些地方插入 LOG，输出屏幕很快就会被大量的调试输出淹没。 LOG 自己也可能导致报错！ 最常见的情况是，LOG 或者 println! 尝试输出一个拥有无效地址的变量。当我们查到某个变量 x 的值可能不对，想用 LOG 输出时，输出语句本身可能会触发 LoadPageFault。通常来说，这是因为内核从用户程序拿到了一个指针(比如 *const u8)，然后没有检查这个指针所指的地址是否无效，就把它类型转换成了变量。此时可以用 :p 来输出它的地址，例如 error!(\"{:p}\", &x)。 另一种常见的情况是，添加或者删除 LOG 语句影响了运行测例的结果。这通常是由于内核栈溢出导致的，下次遇到“加了 print结果居然变了”的情况请先检查堆栈是否够用。 调试技巧：反汇编 上面的报错信息告诉我们，用户程序在 0x572 访问了一个地址 0xb000，而这个用户对这个地址没有读取权限（事实上这一页在用户页表中没有映射，如果不记得页表机制可以回去看 rCore-Tutorial ch4）。我们可以用上一个实验中检查可执行文件内容的方法，去看看 hellostd 里 0x572 这个位置到底是什么。我们在 testcases/ 目录下执行 riscv64-linux-musl-objdump build/hellostd -ld > hellostd.S build/hellostd: file format elf64-littleriscv Disassembly of section .text: 0000000000000508 : exit(): 508: 1101 addi sp,sp,-32 50a: e42a sd a0,8(sp) 50c: ec06 sd ra,24(sp) 50e: 436000ef jal ra,944 512: 434000ef jal ra,946 516: 00007317 auipc t1,0x7 51a: c6233303 ld t1,-926(t1) # 7178 51e: 9302 jalr t1 520: 6522 ld a0,8(sp) 522: 523010ef jal ra,2244 0000000000000526 : _start(): 526: 00007197 auipc gp,0x7 52a: 2da18193 addi gp,gp,730 # 7800 52e: 850a mv a0,sp 530: 00007597 auipc a1,0x7 534: 96058593 addi a1,a1,-1696 # 6e90 538: ff017113 andi sp,sp,-16 53c: a015 j 560 000000000000053e : __dls2(): 53e: 00858613 addi a2,a1,8 542: 418c lw a1,0(a1) 544: 4781 li a5,0 546: 00007717 auipc a4,0x7 54a: c4273703 ld a4,-958(a4) # 7188 54e: 00007697 auipc a3,0x7 552: bf26b683 ld a3,-1038(a3) # 7140 556: 00007517 auipc a0,0x7 55a: c1a53503 ld a0,-998(a0) # 7170 55e: ae4d j 910 0000000000000560 : _start_c(): 560: 6118 ld a4,0(a0) 562: df010113 addi sp,sp,-528 566: 862a mv a2,a0 568: 2705 addiw a4,a4,1 56a: 00371793 slli a5,a4,0x3 56e: 00f606b3 add a3,a2,a5 572: 6694 ld a3,8(a3) 574: 0705 addi a4,a4,1 576: faf5 bnez a3,56a 用上面的代码对比我们在上一个实验中看到的 Rust 测例的反汇编以及目前内核可以运行的 42 hello 两个测例的反汇编，再结合报错时尝试访问的 0xb000 是用户栈顶，可以猜到 0x572 的位置大概是在用户栈上读取信息但读“越界”了。这说明我们的用户栈实现可能还有问题。 是的，我们刻意模糊了这一段发现问题的过程！ 有时我们可以从反汇编代码中看出问题所在，但这并不总是行得通。在这个例子中，“用户栈有问题”就是一个“知识鸿沟”，很难直接用 debug 技巧解决。实际开发可能需要大量查阅资料、询问他人、翻找往届能通过测例的内核代码，才能知道具体出错的原因。所以这一次我们就直接假设跳过了查询的过程，直接看如何解决这个bug。 "},"docs/lab2/usecode.html":{"url":"docs/lab2/usecode.html","title":"引入外部代码","keywords":"","body":"引入外部代码 我们希望修改用户栈的实现，以满足标准库的需求。具体来说，用户栈需要满足上一章中提到的 ELF 文件规范： position content size (bytes) + comment ------------------------------------------------------------------------ stack pointer -> [ argc = number of args ] 8 [ argv[0] (pointer) ] 8 (program name) [ argv[1] (pointer) ] 8 [ argv[..] (pointer) ] 8 * x [ argv[n - 1] (pointer) ] 8 [ argv[n] (pointer) ] 8 (= NULL) [ envp[0] (pointer) ] 8 [ envp[1] (pointer) ] 8 [ envp[..] (pointer) ] 8 [ envp[term] (pointer) ] 8 (= NULL) [ auxv[0] (Elf32_auxv_t) ] 16 [ auxv[1] (Elf32_auxv_t) ] 16 [ auxv[..] (Elf32_auxv_t) ] 16 [ auxv[term] (Elf32_auxv_t) ] 16 (= AT_NULL vector) [ padding ] 0 - 16 [ argument ASCIIZ strings ] >= 0 [ environment ASCIIZ str. ] >= 0 (0xbffffffc) [ end marker ] 8 (= NULL) (0xc0000000) 0 (virtual) ------------------------------------------------------------------------ 注意因为目标架构 riscvgc64 是 64 位，所以网页中的 4 在我们这里换成了 8，而 8 换成了 16。 你当然可以手动实现上面的内容，但我们想趁机向你介绍如何引入其他内核的实现来完成这个任务。 找到对应模块 一般来说，每一届操作系统比赛都会沿用往年的测例，然后添加新测例，因此这些通用的功能很可能就是往届内核里造过的“轮子”，而参考这些内核的实现将会是绝大部分同学不得不经历的过程。比赛本身并不排斥大家用往年的实现，只要在文档里说明来源即可。 那么这又引出另一个问题，参加比赛能不能直接沿用往届的完整内核来开发呢？当然可以！ 事实上，下一章的实验就是基于一个往届的内核来做的。不过，往年内核的功能不能算是你在本届比赛中的贡献，而别人的代码总是会比自己的代码难理解许多，所以单纯想一口吃成胖子只会让后续的开发举步维艰。 我们需要实现的模块在大部分内核中被叫做 ELF Loader，因为初始化用户栈、生成环境变量等信息发生在“用户程序加载进内核”的过程中。你可以在比赛页面查询往年内核实现赛的获奖名单，然后在 github 或者 官方 gitlab 上搜索对应的内核项目。在本次实验中，我们用这个内核的 kernel/src/loaders 模块。 我们开发的是 Rust 内核，所以最好的情况当然是直接使用包装成 Rust Crate 的模块，这样我们只需要在 os/Cargo.toml 里引入模块作为依赖，就可以在内核中使用它了。不过就目前来说，操作系统比赛的内核实现中的大部分还没有这么高的模块化，只能使用复制粘贴代码的方式来“复用模块”。但模块化是本指导书的目标之一，在后续实验中我们会实现一个独立于内核的 Rust Crate，它支持某项特定的内核功能。 修改模块以适配内核 在测例仓库的 lab2 分支的 loaders 子目录下有已经修改好的模块，可以按照测例仓库 README.md 中提到的方法，把它直接放进你的 os/src 下。 本节剩下的内容只是在展示和解释我们修改原始模块的过程，以便你学习如何为内核添加其他模块。你当然可以用另一种方式精简这个模块或者使用其他模块。 允许新模块的 warning 以及缺失文档问题 首先，我们复制这个文件夹的内容到 rCore-Tutorial 的 os/src 目录下，然后在 os/src/main.rs 中引入这一模块（添加一条 pub mod loaders），尝试直接运行 make run。不出意外地它报错了，其中一类错误如下： error: unused import: `sections::SectionData` --> src/loaders/mod.rs:19:5 | 19 | sections::SectionData, | ^^^^^^^^^^^^^^^^^^^^^ | note: the lint level is defined here --> src/main.rs:22:9 | 22 | #![deny(warnings)] | ^^^^^^^^ = note: `#[deny(unused_imports)]` implied by `#[deny(warnings)]` 报错信息指出，其中有一些变量没有被使用到。为什么这样的情况不是 warning 而是 error 呢？因为 main.rs 在开头特地指明了 #![deny(missing_docs)] 和 #![deny(warnings)]，表示所有缺失文档的文件、类、函数乃至所有 warning 都不被允许。这是一个非常好的特性，可以有效改善代码质量，但在调试时我们可以针对对应模块暂时取消它： // at os/src/main.rs #[allow(missing_docs)] #[allow(warnings)] pub mod loaders; 删掉不需要的功能和所有不存在的引用 看一下这个模块里的代码，发现它其实做了等同于 rCore-Tutorial 内核中 os/src/mm/memory_set.rs:MemorySet::from_elf() 的事情，也就是解析 ELF 文件的每一个 LOAD 段并塞入用户页表中。但我们只想要它处理用户栈的部分，也即： let info = InitInfo { ...... }; info!(\"info {:#?}\", info); let init_stack = info.serialize(stack_top); debug!(\"init user proc: stack len {}\", init_stack.len()); stack_pma.write(USER_STACK_SIZE - init_stack.len(), &init_stack)?; stack_top -= init_stack.len(); 这一部分，所以我们可以把 init_vm 函数里的其他部分删掉（除了获取 elf_base_vaddr 变量的一段，因为这个变量会被 info = InitInfo {... } 用到）。其他用不到的函数和类也可以删掉，只留下 ElfLoader 里的 new 和 init_vm。然后把每个文件开头用不到的引用以及不存在的模块引用删掉，它们并不属于我们的 rCore-Tutorial 内核。 替换原代码中的函数参数、返回值、常量 接下来就需要分门别类分析各个报错的位置了。举三个例子： ElfLoader::new 函数的返回值 OSResult 这个类不存在，但看函数实现可以发现它其实是想返回 ElfLoader 这个类本身或者返回一个报错字符串。所以我们直接将返回类型改为 Result，错误消失了。 ElfLoader::init_vm 的参数中，有一个 vm: &mut MemorySet,。MemorySet 看起来和我们内核中的 MemorySet 是类似的，但通过 vm: &mut MemorySet 输入会报错。回顾 os/src/task/process.rs:ProcessControlBlock::exec 函数，我们使用 memory_set 的方式应该是获取一个 usize 类型的 memory_set.token()，所以这里我们把这个参数替换成 memory_token: usize。此外，由于我们的 os/src/mm/memory_set.rs:MemorySet::from_elf() 已经生成了用户栈底地址，所以还要加一个参数 stack_top: usize 代码中用到一些常量，如 PAGE_SIZE USER_STACK_SIZE 可以用我们内核中 os/src/config.rs 中对应的常数代替。如果不清楚常数的含义，可以选择去查这个模块来源的内核。 总之，我们将替换原代码中的函数参数、返回值、常量，改成自己内核中对应的值 必要时增写函数或者功能 最后，我们还需要处理代码中用到但我们目前内核中没有的功能。通过查模块来源的内核的注释（或者通过上一节教的全局搜索）可以得知，原代码中的 stack_pma.write(USER_STACK_SIZE - init_stack.len(), &init_stack)?; 一行是将 init_stack 里的内容全部写到用户栈上。我们的内核没有这么方便的函数，但有一个类似的 translated_byte_buffer，可以利用它把原代码的这一行改写成： let stack = translated_byte_buffer(memory_token, stack_top as *const u8, init_stack.len()); // 接下来要把 init_stack 复制到 stack 上 let mut pos = 0; for page in stack { let len = page.len(); page.copy_from_slice(&init_stack[pos..pos + len]); pos += len; } assert!(pos == init_stack.len()); 之后，把模块前的 #[allow(missing_docs)] 和#[allow(warnings)] 删掉，就几乎得到在测例仓库的 lab2 分支的 loaders 子目录的模块了。 部分同学可能会有疑问：info = InitInfo {... } 里定义的 auxv 以及用到的 elf_base_vaddr 事实上也都是没用的，全删掉也不影响运行，为什么测例仓库给出的模块没有处理它们？ 这是因为我们在添加一个新模块时，很难准确判断哪些东西是不必要的。在本实验中我们要用“用户栈的预处理”这一部分，其他的可以删除，但并不知道这一部分之中哪些是必要的。在这种情况下，尽可能保留原有模块的部分在某种程度上可以提高运行成功的概率。等到我们成功运行这个模块之后，可以再来考虑删掉哪些部分。 事实上，在比赛决赛第一阶段的 libc-test 测例中，需要使用到原 loaders 模块的所有内容，所以所有删掉的代码最后都是要加回来的。 "},"docs/lab2/gdb.html":{"url":"docs/lab2/gdb.html","title":"GDB 调试","keywords":"","body":"GDB 调试 在引入 loaders 模块后，我们仍然没有跑通 hellostd，这次的运行结果是 >> hellostd Shell: Process 2 exited with code -4 回顾我们第一次运行这个测例时的输出，可以发现仍然是 user_shell 的同一个位置报错（虽然 user_shell 的其他地方会 return -4，但哪些位置的错误输出都是以 Error when 开头，和我们看到的输出不符）。也就是说，这个程序执行失败是在 user_shell 在 waitpid 等待它执行完成的时候，得知了程序返回 -4 的消息。 继续依葫芦画瓢，在 os/src 中搜索 -4，可以找到 src/task/signal.rs 中的 Some((-4, \"Illegal Instruction, SIGILL=4\"))。问题是类似的，但这次我们没有看到 ERROR 输出。这是因为 rCore-Tutorial 实验框架忘记在 os/src/trap/mod.rs:trap_handler 的 IllegalInstruction 一项里加错误输出了，我们给它补上： ...... Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) | Trap::Exception(Exception::InstructionFault) | Trap::Exception(Exception::InstructionPageFault) | Trap::Exception(Exception::LoadFault) | Trap::Exception(Exception::LoadPageFault) => { error!( \"[kernel] trap_handler: {:?} in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", scause.cause(), stval, current_trap_cx().sepc, ); current_add_signal(SignalFlags::SIGSEGV); } Trap::Exception(Exception::IllegalInstruction) => { error!( \"[kernel] trap_handler: {:?} in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.\", scause.cause(), stval, current_trap_cx().sepc, ); current_add_signal(SignalFlags::SIGILL); } Trap::Interrupt(Interrupt::SupervisorTimer) => { set_next_trigger(); check_timer(); suspend_current_and_run_next(); } ...... 再次运行，我们看到了这样的输出 >> hellostd [ERROR] [kernel] trap_handler: Exception(IllegalInstruction) in application, bad addr = 0x464c457f, bad instruction = 0x0, kernel killed it. Shell: Process 2 exited with code -4 这次的情况略有不同。出错的指令地址是 0x0，也就是说，用户程序尝试在 0x0 执行一条指令。显然，问题不在于 0x0 有什么，而在于用户程序是怎么跑到那里去的。我们用 gdb 来实时跟踪用户程序的执行过程。 精简 gdb 命令 一千个人有一千种方式使用 gdb，我们在此仅介绍最基本的一种。你可能会需要下面这些命令： b *0x12345678 表示在 0x12345678 这个地址设置断点 i 可以查看各种信息。例如 i b 是查看断点，i reg 是查看所有通用寄存器 d 1 可以删除 1 号断点。先用 i b查看断点编号再删除 x/10i $pc 表示输出从 pc 当前位置开始往下的十条指令。pc 可以换成其他地址 si 表示向下执行一条指令 n 可以执行下一行代码，不进入本行执行的函数。对用户程序不一定有效 c 表示继续运行，直到遇到下一个断点为止 ctrl+C 可以打断运行，如果一次 c 执行太久没有相应可以试试这个 q 可以退出 gdb 内核中运行 gdb 的注意事项 上面给出的命令中没有跟查看源代码或者函数符号相关的命令，这是因为 gdb 本质上是在对内核运行。而对于内核运行起来后实时加载的用户程序，gdb 无法掌握它们的符号信息，因而只能通过具体的地址进行调试，也只能看到汇编指令。 如果有 gdb 扩展或者其他项目支持查看内核中加载的用户程序的符号，可以联系我们，后续加进教程里 不过，查看内核的源代码是可以的。在 os/Makefile 下把第 2 行的 MODE := release 改为 MODE := debug 就可以了。 gdb 也不支持跨地址空间的查找。换句话说，它只知道当前能不能访问某个地址（虚拟地址），不会管现在的页表在哪，所以内核调试时经常会遇到因为地址当前无法访问而打不上断点的情况。这时可分为以下情况处理： 把断点打在内核入口，也即 0x80200000 处，然后使用 c 命令跳过去。之后就可以打大部分内核符号的断点了。 把断点打在 mm::init() （页表初始化函数）然后使用 c 命令跳过去，再用 n 指令跳过这段流程，就可以打页表中有映射的地址的断点了，例如跳板页 TRAMPOLINE。 一般来说，如果想打用户程序的断点，可以把断点先打在内核的 __alltraps 和 __restore 上，这是在 os/src/trap/trap.S 中定义的从内核到用户程序的入口和异常中断的入口。然后手动执行直到它跳到用户程序的地址，之后就可以打用户地址的断点了。 但 rCore-Tutorial 实际上的 __alltraps 和 __restore 会被复制到跳板页 TRAMPOLINE 去执行。对于 __alltraps，它就是跳板页地址 TRAMPOLINE 对于 __restore，我们可以先 b __restore b __alltraps 查看这两个地址的偏移，然后算出它相对于 TRAMPOLINE 的偏移，从而在跳板页的对应位置打上断点 上面的过程实在比较麻烦，可以有以下几种办法改进 先使用 c 命令，等待程序运行到 user_shell 等待输出的时候，再 ctrl+C，就可以打用户地址空间的断点了。但缺点是此时无法打内核的断点 把上面断点的流程写进 gdb 脚本 把初始化页表放在内核启动的最开头 entry.asm 里，可以省去第二步；使用单页表（见rCore-Tutorial 指导书 ch4 练习）把跳板页去掉，可以直接把断点打在 __alltraps 和 __restore，省去第三步。 使用 rCore-Tutorial 自带的命令调试 在 os/Makefile 的最下面有这些命令 debug: build @tmux new-session -d \\ \"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) -s -S\" && \\ tmux split-window -h \"riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'\" && \\ tmux -2 attach-session -d gdbserver: build @qemu-system-riscv64 -M 128m -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) \\ -drive file=$(FS_IMG),if=none,format=raw,id=x0 \\ -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 \\ -s -S gdbclient: @riscv64-unknown-elf-gdb -ex 'file $(KERNEL_ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234' 下面尝试使用 gdbserver 和 gdbclient 进行调试。 首先打开两个终端，它们都切换到 os/ 这个目录。然后在第一个终端执行 make gdbserver，在第二个终端执行 make gdbclient。如果在第二个终端看到下面的输出，表示连接成功 ❯ make gdbclient GNU gdb (SiFive GDB 9.1.0-2020.08.2) 9.1 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=x86_64-linux-gnu --target=riscv64-unknown-elf\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: . Find the GDB manual and other documentation resources online at: . For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\". Reading symbols from target/riscv64gc-unknown-none-elf/release/os... The target architecture is assumed to be riscv:rv64 Remote debugging using localhost:1234 warning: Architecture rejected target-supplied description 0x0000000000001000 in ?? () (gdb) 先预想一下接下来发生什么事情： initproc 先启动，然后是 user_shell 我们会在 user_shell 里输入 hellostd 这个字符串 之后 os/src/task/process.rs:ProcessControlBlock::exec 会加载 hellostd 这个测例。 等到它运行到用户态时，会报错 由此可以设计出一种断点流程（(gdb)开头的内容都是在 gdb client 那个终端输入的）： (gdb) b ProcessControlBlock::exec (gdb) c // 此时执行到该断点，程序暂停。看一下 gdb server 那个终端，得知是正在启动 user_shell (gdb) c // 此时没有执行到 exec 的断点。 // 切到 gdb server 那个终端，发现 rCore-Tutorial 内的终端已启动，此时输入 hellostd // 此时执行到 exec 的断点，程序暂停。hellostd 测例准备启动，下一个断点打到 __restore (gdb) b *0xfffffffffffff060 (gdb) c // 此时执行到 __restore 的断点，程序暂停。删除 __restore 的断点，因为它在进入用户态后会无法访问 (gdb) d 2 (gdb) si // 按住回车不动，等 gdb 一直往下执行，直到切到用户地址 // 然后对一下反汇编结果，确认当前是否在 hellostd 测例中 (gdb) x/10i $pc (gdb) si // 按住回车不动，等 gdb 一直往下执行，直到切到用户地址，看哪里跳转到0 执行上面的流程，最后会发现是在 0x608 这个地址跳转到 0 的。看一下反汇编这个地址附近的指令： 5fc: a0878793 addi a5,a5,-1528 600: 639c ld a5,0(a5) 602: 85b2 mv a1,a2 604: 21010113 addi sp,sp,528 608: 8782 jr a5 0x608 的一条 jr a5 跳转到了 0x0。这个错误的 a5 是在上面 0x600 的一条 ld a5,0(a5) 加载的。 这时可以按 q 退出 gdb，重新走一遍上面的流程，在最后一步进入 hellostd 的用户态时，加一个断点 b *0x600，就可以 c 跳到这一条加载指令之前。这时通过 i reg 查看通用寄存器的值，可以得知 a5 的值是 0x7000。 那么 0x7000 的位置应该有值吗？如果它不是 0，又应该是多少呢？ 收尾工作 内核里有一个函数会直接操作用户地址空间，就是 os/src/mm/memory_set.rs:MemorySet::from_elf()。自然地我们会想要加一条调试输出检查它加载 ELF 文件时每一段的地址： pub fn from_elf(elf_data: &[u8]) -> (Self, usize, usize) { let mut memory_set = Self::new_bare(); // map trampoline memory_set.map_trampoline(); // map program headers of elf, with U flag let elf = xmas_elf::ElfFile::new(elf_data).unwrap(); let elf_header = elf.header; let magic = elf_header.pt1.magic; assert_eq!(magic, [0x7f, 0x45, 0x4c, 0x46], \"invalid elf!\"); let ph_count = elf_header.pt2.ph_count(); let mut max_end_vpn = VirtPageNum(0); for i in 0..ph_count { let ph = elf.program_header(i).unwrap(); if ph.get_type().unwrap() == xmas_elf::program::Type::Load { let start_va: VirtAddr = (ph.virtual_addr() as usize).into(); let end_va: VirtAddr = ((ph.virtual_addr() + ph.mem_size()) as usize).into(); error!(\"start_va {:x} end_va {:x}\", start_va.0, end_va.0); ...... 再次运行测例，得到输出： >> hellostd [ERROR] start_va 0 end_va 5aac [ERROR] start_va 6e70 end_va 7820 这个结果和其他测例有什么不同吗？可以再试试 hello 42 乃至原本的 Rust 测例比如 ch2b_power_3，发现只有 hellostd 的 start_va 不是页对齐的。 继续看 from_elf 这个函数，会发现在下面这一句 memory_set.push( map_area, Some(&elf.input[ph.offset() as usize..(ph.offset() + ph.file_size()) as usize]), ); 实际上是默认了每一个 LOAD 段都是页对齐的。因为它把来自 ELF 文件的段数据 elf.input 直接塞进 map_area 的区间里，没有做任何偏移。我们终于找到了 bug 的源头。于是我们将这段代码改成考虑偏移的版本： if start_va.page_offset() == 0 { memory_set.push( map_area, Some(&elf.input[ph.offset() as usize..(ph.offset() + ph.file_size()) as usize]), ); } else { let data_len = start_va.page_offset() + ph.file_size() as usize; let mut data: Vec = Vec::with_capacity(data_len); data.resize(data_len, 0); data[start_va.page_offset()..].copy_from_slice(&elf.input[ph.offset() as usize..(ph.offset() + ph.file_size()) as usize]); memory_set.push( map_area, Some(data.as_slice()), ); } 其中 else 分支创建了一个 data Vector，它在页偏移的部分填 0，后面再存来自 elf.input 的真正的数据。 至此，我们终于解决了 Shell: Process 2 exited with code -4 的问题。 "},"docs/lab2/syscall.html":{"url":"docs/lab2/syscall.html","title":"通过 Manual Page 添加 Syscall","keywords":"","body":"通过 Manual Page 添加 Syscall 加上上一章里对 os/src/mm/memory_set.rs:MemorySet::from_elf() 的修改，现在我们再次运行 hellostd 测例。 不出意外的话，输出应该是（根据你原仓库的实现，报错行号可能略有不同）： >> hellostd [kernel] Panicked at src/syscall/mod.rs:168 Unsupported syscall_id: 96 坏消息是，它仍然没有运行成功；好消息是，这实际上已经是最后一步了！只要我们按照 rCore-Tutorial 那样填补上缺失的 syscall，就可以成功运行这个测例。不过，这时候就不是指导书来定义这些 syscall 了，而是需要查看通用的 syscall 标准。 Syscall 定义 通常来说，syscall 定义可以在 man7.org 查到，比如这是一个 sys_clone 的定义，里面包含了你可能需要知道的绝大部分东西，包括 接口定义和参数列表int clone(int (*fn)(void *_Nullable), void *stack, int flags, void *_Nullable arg, ... /* pid_t *_Nullable parent_tid, void *_Nullable tls, pid_t *_Nullable child_tid */ ); syscall 的语义以及各个参数的语义。这包括关于 syscall 本身的描述和各个参数的描述。如果参数包括标志位，还会提每一个标志位的含义。不过这个页面并不会告诉你在哪一个位。下面节选一些 sys_clone 的定义 DESCRIPTION These system calls create a new (\"child\") process, in a manner similar to fork(2). By contrast with fork(2), these system calls provide more precise control over what pieces of execution context are shared between the calling process and the child process. ...... The clone() wrapper function When the child process is created with the clone() wrapper function, it commences execution by calling the function pointed to by the argument fn. (This differs from fork(2), where execution continues in the child from the point of the fork(2) call.) The arg argument is passed as the argument of the function fn. clone3() ...... Equivalence between clone() and clone3() arguments ...... The flags mask CLONE_CHILD_CLEARTID (since Linux 2.5.49) Clear (zero) the child thread ID at the location pointed to by child_tid (clone()) or cl_args.child_tid (clone3()) in child memory when the child exits, and do a wakeup on the futex at that address. The address involved may be changed by the set_tid_address(2) system call. This is used by threading libraries. CLONE_CHILD_SETTID (since Linux 2.5.49) ...... CLONE_CLEAR_SIGHAND (since Linux 5.5) ...... 返回值 错误类型。在 rCore-Tutorial 中，如果一个 syscall 执行失败，通常是直接返回 -1 的。但在 POSIX syscall 中，syscall 可以返回不同的负数，代表不同的错误类型。一些标准库程序会通过判断不同的错误类型来执行不同的代码，所以 debug 时别忘了你给用户程序返回的错误类型也可能出错。 其他需要说明的问题，比如存在的版本冲突、历史版本问题、额外的说明、代码示例等等 一些链接，可以点到相关的其他 syscall 如何搜索到Syscall定义 一般来说，如果你知道 syscall 的名字。总是可以用搜索引擎找到上面的页面的。 但我们现在只知道 syscall 的 ID 是 96，怎么知道它是谁呢？ 可以用网上整理好的博客，比如这一篇，在网页里搜索 96 就能找到我们想要的 sys_set_tid_address。 可以通过源代码查询。例如我们在最初的实验 中下载的交叉编译工具链使用的 musl-libc。可以在这里 下载到 musl 库的源代码，然后在目录下的 arch/riscv64/bits/syscall.h.in 中找到 syscall 对应的名字。 回到主线 至少在参加比赛这个阶段，当我们要实现一个 syscall 时不需要实现定义里的所有内容。定义中 90% 的部分可能只会有不到 1% 的应用程序会使用。因此，我们只希望支持最基本的功能，让用户程序成功运行就行，更详细的定义可以以后需要时再加。 现在我们需要实现 96 号 syscall set_tid_address，你可以在这里找到它的描述。 观察一下它的描述： SYNOPSIS #include /* Definition of SYS_* constants */ #include pid_t syscall(SYS_set_tid_address, int *tidptr); Note: glibc provides no wrapper for set_tid_address(), necessitating the use of syscall(2). DESCRIPTION For each thread, the kernel maintains two attributes (addresses) called set_child_tid and clear_child_tid. These two attributes contain the value NULL by default. set_child_tid If a thread is started using clone(2) with the CLONE_CHILD_SETTID flag, set_child_tid is set to the value passed in the ctid argument of that system call. When set_child_tid is set, the very first thing the new thread does is to write its thread ID at this address. clear_child_tid If a thread is started using clone(2) with the CLONE_CHILD_CLEARTID flag, clear_child_tid is set to the value passed in the ctid argument of that system call. The system call set_tid_address() sets the clear_child_tid value for the calling thread to tidptr. When a thread whose clear_child_tid is not NULL terminates, then, if the thread is sharing memory with other threads, then 0 is written at the address specified in clear_child_tid and the kernel performs the following operation: futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0); The effect of this operation is to wake a single thread that is performing a futex wait on the memory location. Errors from the futex wake operation are ignored. RETURN VALUE set_tid_address() always returns the caller's thread ID. ERRORS set_tid_address() always succeeds. 会发现这个 set_child_tid 和 clear_child_tid 的描述都是用 If a thread is started using clone(2) with... 开头的，这里的 clone 是 sys_clone，本质上和我们的 sys_fork 同功能，但提供更多的参数。因为目前内核里对 fork 没有更多的参数支持，我们也显然不会满足这里提到的 If，所以这两个情况目前都是不必要的。 由于 clear_child_tid 在目前的内核中不存在，所以下一行说的 sets the clear_child_tid value for the calling thread to tidptr. 的情况也可以忽略，这样连这个 syscall 的唯一参数 tidptr 也可以不用管，我们直接看返回值就好了。 选择忽略哪些描述、实现哪些描述并不简单。一般情况下，可以运行一个用户程序，看它在调用这个 syscall 的时候给了哪些参数，然后在内核中选择性忽略它没有给的参数。不过有时候用户程序给出的参数也是不必要的，这需要反复 debug 才能知道。 返回值告诉我们，这里需要返回调用者的线程 ID。考虑 rCore-Tutorial 和实际 Linux 的线程定义差异（下一节详细说明），我们在此返回 pid。这样我们直接使用已有的 sys_getpid() 函数就好了。 注意，返回 sys_getpid 而不是 sys_gettid！ 重复一遍，返回 sys_getpid 而不是 sys_gettid！ 我们在 os/src/syscall/mod.rs 添加上这个 syscall： /// set_tid_address syscall pub const SYSCALL_SET_TID_ADDRESS: usize = 96; /// handle syscall exception with `syscall_id` and other arguments pub fn syscall(syscall_id: usize, args: [usize; 4]) -> isize { match syscall_id { ...... SYSCALL_SET_TID_ADDRESS => sys_getpid(), _ => panic!(\"Unsupported syscall_id: {}\", syscall_id), } } 再次运行程序...随后它就会卡在另一个 syscall 上：Unsupported syscall_id: 29。 不过接下来就是你的任务了：看看布置实验那一节的要求，补上缺失的 syscall 使得 hellostd 测例运行成功。 "},"docs/lab2/tid.html":{"url":"docs/lab2/tid.html","title":"规范：TID 定义问题","keywords":"","body":"规范：TID 定义问题 rCore-Tutorial 的接口设计受到 zircon 影响，且为了教学简化了许多模块的设计。但在支持实际的 Linux 应用时，我们需要改掉这些设计。 本节介绍rCore-Tutorial 的 tid 与标准 tid 有何不同，之后会有更多这样的小节说明rCore-Tutorial其他模块中的规范问题。 POSIX syscall 的定义 在 Linux 中，每个线程有全局唯一的线程ID，也就是 tid，且每个进程的初始线程的 tid 等同于进程的 pid。举个例子来说，可能是这样： 线程 pid tid a 1 1 b 2 2 c 1 3 d 1 4 e 5 5 这里 a,c,d 是同一个进程里的线程，b e 分别是独立的进程。再举几个例子： 如果往 a,c,d 里再加一个线程 f，它可能是 pid=1,tid=6，当然其他大于 6 的 tid 也是合法的。 如果进程 d 退出，然后其他进程再创建一个进程 d2，那么它可能是 pid=4,tid=4，也可能是其他的 pid=x,tid=x(x>=6)。总之，tid不能重复。 rCore-Tutorial 而相对的，在 rCore-Tutorial 中，每个进程内部的每个线程的ID独立排序，且每个进程的初始线程的 tid 为 0。也就是像下面这样 线程 pid tid a 1 0 b 2 0 c 2 1 d 3 0 e 2 2 f 1 1 这里 a,f 是同一个进程内的两个线程，b,c,e 是同一个进程内的三个线程，d 是一个独立进程。 实现建议 在通过比赛测例时，你需要修改 tid 实现以适应实际 Linux 应用的需求。但在本次实验中不需要改下面的实现。 所以我们在修改 tid 的实现时，可以把 tid 改成原来那个全局唯一的 pid，也即 每次生成一个进程时，为它分配一个全局ID作为 tid。然后令它的 pid 的值为 tid。 每次生成一个线程时，也为它分配一个全局ID作为 tid。然后令它的 pid 的值为生成它的线程的 pid（这表示它们俩在同一个进程里） 扩展阅读：waittid 如果认真看 syscall列表和 sys_wait 的文档，你可能会注意到这里没有 waittid，只有 wait,waitpid,waitid（注意 waitid=wait+id）。那么 Linux 应用如何实现 rCore-Tutorial 的 waittid 呢？你可能已经在其他项目中见过它的形式了： int pthread_join(pthread_t, void **); 在 musl 源码中，pthread_join 最终会调用 src/thread/pthread_join.c/__pthread_timedjoin_np。我们可以简单分析这个函数是如何实现等待一次线程退出的： static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) { int state, cs, r = 0; __pthread_testcancel(); __pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs); if (cs == PTHREAD_CANCEL_ENABLE) __pthread_setcancelstate(cs, 0); while ((state = t->detach_state) && r != ETIMEDOUT && r != EINVAL) { if (state >= DT_DETACHED) a_crash(); r = __timedwait_cp(&t->detach_state, state, CLOCK_REALTIME, at, 1); } __pthread_setcancelstate(cs, 0); if (r == ETIMEDOUT || r == EINVAL) return r; __tl_sync(t); if (res) *res = t->result; if (t->map_base) __munmap(t->map_base, t->map_size); return 0; } 其中， 两次 __pthread_setcancelstate 分别表示关闭/打开取消请求。线程可以通过 pthread_cancel 函数去试图终止其他线程的运行，但其他线程也可以设置是否响应。在 __pthread_timedjoin_np 里的这两句 __pthread_setcancelstate 中间的代码运行时，当前线程是不会响应取消请求的。你可以类比内核中“关闭异常中断”的过程。 __timedwait_cp 会使用一个 sys_futex 在某个内存地址设置一个条件变量。你可以将它理解为类似 rCore-Tutorial ch8 中条件变量一节的实现。 当当前线程所等待的那个线程退出时，它会修改表示线程状态的条件变量的值。这些条件变量的地址和上一节中我们“跳过实现”的 sys_set_tid_address 的参数有关。 这会唤醒正在等待的当前线程，使它获取返回结果 r 并继续执行。 "},"docs/lab2/exercise.html":{"url":"docs/lab2/exercise.html","title":"练习","keywords":"","body":"练习 编程作业 可以使用前一个实验完成后的代码来做本实验。如果没有完成前一个实验，也可以从 rCore-Tutorial ch8 开始修改，不影响实验本身。如果没有做到 ch8，也可以用全新的 ch7 来做实验。 在本实验中，你需要： 跟随前面文档的指引修改内核，使得运行测例 hellostd 可以输出 Unsupported syscall_id: 29。 根据 通过 Manual Page 添加 Syscall 一节中介绍的方法，添加其他 syscall，使得测例 hellostd 可以正常运行并输出 hello std。（提示：只有一个新的 syscall 需要实现，其他的都可以用内核中现有 syscall 代替或者什么都不做直接返回 0） 问答作业 查询标志位定义。 标准的 waitpid 调用的结构是 pid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);。其中的 options 参数分别有哪些可能（只要列出不需要解释），用 int 的 32 个 bit 如何表示？ 你可能需要根据通过 Manual Page 添加 Syscall一小节的指引下载 musl 源码，并用寻找报错位置 中提到的全局搜索技巧进行分析。 报告要求 完成编程作业，描述实现思路以及修改的代码。本章没有自动评测，我们会人工检查你的代码实现和报告。 完成问答题。 推荐使用 markdown 格式 和 rCore-Tutorial 实验类似，报告放在 reports/文件夹下，但命名为 labr2.md或labr2.pdf "},"docs/lab3/intro.html":{"url":"docs/lab3/intro.html","title":"实验概述","keywords":"","body":"在一个往届参赛内核上支持 busybox mv 本实验不需要其他前置知识。 实验准备 本实验使用 Starry 内核的 467c73f commit 版本，它基于 Arceos 实现，获得了 2023 年全国大学生计算机系统能力大赛操作系统设计赛内核实现组的二等奖。 你可以 fork 这个代码仓库：https://github.com/Azure-stars/Starry，然后在 467c73f 建立一个新分支： git checkout 467c73f git checkout -b lab3 随后就可以开始实验了。 不用害怕代码量太大，编者也不是完成这个内核的参赛队伍的成员，我们会带你以一个完全陌生的视角走进 Starry，并在上面完成一个小功能。你也可以用本章的技巧去学习、改进往届比赛的其他内核。 实验概述 在比赛开发过程中，还有许多本教程中没有提及的难点，涉及许多课内未曾提及的规范和约束。通常来说，当你不知道如何实现一个新测例时，最简单的办法是看看之前参加操作系统比赛的同学是如何实现的。 “运行一个陌生的内核并读懂它的代码”并不是一个简单的任务，况且据大部分比赛内核是为了通过测例而设计的，只包含少量介绍其特性和内核架构的文档或开发日志。所以相较于有指导书和大量注释的 rCore-Tutorial ，阅读它们的代码要困难许多。在本章节中，我们将 简单介绍往届的操作系统比赛获奖内核，以及运行旧内核时的一些常见问题 以 Starry 为例，带大家了解如何运行、读懂、简单修改一个陌生的内核 介绍如何利用 strace 进行调试和对拍 尝试在 Starry 进行 syscall 层面的调试，以添加一个新功能（而不需要阅读它的所有代码） 我们仍会在介绍的过程中提供一些关于 Starry 的信息，以便你了解它的实现。另外，实验中不仅在 Starry 目录下操作，偶尔也会让你在本机系统或者前两章实验的 rCore-Tutorial 下操作。当出现这样的情况时，我们会具体说明。 另外，比赛鼓励大家使用已有实现作为 baseline，所以你不一定要把所有别人写过的功能都重新写一遍，也可以选择以现有内核为基础继续开发。事实上往届获奖内核中就有很多这样的例子。 更多关于 Starry 的文档 如果你有兴趣了解关于 Starry 的信息，可以看看它的设计文档 "},"docs/lab3/before.html":{"url":"docs/lab3/before.html","title":"部分往届内核及运行指引","keywords":"","body":"部分往届内核及运行指引 除了这次试验要介绍的 Starry 之外，我们还推荐参考以下内核的实现： 名字和链接 学校 年份 使用语言 部分特性 umi 西安交通大学 2023 Rust 中断驱动的全局异步；函数自动转换为 future；模块化；用户地址检查；基于smoltcp 的协议栈 Titanix 哈尔滨工业大学（深圳） 2023 Rust 部分异步；用户地址检查；支持 redis、gcc、vi 和一个 httpserver ByteOS 河南科技大学 2023 Rust 异步函数包装；支持 redis、gcc、ssh 和一个 httpserver alien 北京理工大学 2023 Rust 支持 GUI；支持 bash、redis、sqlite3 FarmOS 北京航空航天大学 2023 C FTLOS 哈尔滨工业大学（深圳） 2022 Rust 异步函数包装；RCU；syscall 快速路径 maturin 清华大学 2022 Rust cargo生成文档；模块化；支持 redis、gcc Oops 哈尔滨工业大学（深圳） 2022 Rust 支持 binutils、vi、rustc TatakaOS 杭州电子科技大学 2022 C 支持 vi、quickjs、xc（一个C的解释器） NPUcore 哈尔滨工业大学（深圳） 2022 Rust 带缓存的VFS；支持 bash TLTS 北京航空航天大学 2022 C 支持 redis、gcc UltraOS 哈尔滨工业大学（深圳） 2021 Rust 运行时调试工具 404 中国科学院大学 2021 C xv6 华中科技大学 2021 C 多核启动 上表中没有提及比赛要求实现的测例集和应用，只列出了要求之外的部分。另外，对于内核特性的描述比较主观。如果你有不同的想法，可以在本项目的 issue 告诉我们。 在 2021 年的第一届比赛时，还没有队伍能够完成赛事方提供的所有测例（主要是 lmbench 测例集），所以内核本身的特色会比较少。而在 2022 年的第二届比赛，有很多队伍完成了所有测例，并开始尝试支持更大的应用程序。到了 2023 年的第三届比赛，参赛队伍不仅在自己的内核上运行比赛没有要求的应用程序，还支持了许多现代内核特性。 表中的大部分内核都是用 Rust 写的。如果你找得足够仔细的话，这些 Rust 内核都在文档里鸣谢了 rCore-Tutorial 或者直接使用了它的的代码，因此学习 rCore-Tutorial 本身会对你理解他们的代码有很大的帮助！当然，每一届的内核也会参照往届其他内核的实现。在完成自己的内核时，不要忘了尝试运行一下这些优秀的内核，这会帮你节省很多 debug 的时间。 运行注意事项 由于比赛包含一些未写明的机制、评测机环境、测例约定，所以尝试运行它们可能会遇到一些问题 如果是 2022 或 2023 年的作品，且赛后在 github 上有维护，那么大概率可以直接运行，不会和比赛环境有太大联系。本实验要用的 Starry 也是这种模式，且目前仍然在持续更新。 如果是来自 gitlab 的链接，那么有可能这个内核只能在比赛环境运行，我们想在赛后运行它可能要花一些功夫。 具体来说，可能有以下问题 Rust 编译器版本 目前所有比赛中的 Rust 内核以及 rCore-Tutorial 都是用 rust-nightly 版本。在项目的根目录下，运行 cargo --version 即可查看项目使用的 Rust 版本。nightly 的更新非常频繁，包含许多不稳定的特性，而这些特性随时可能改动。所以往年比赛时用的 nightly 版本现在可能已经不再适用。 这个版本记录在项目的根目录下的 rust-toolchain.toml 或者 rust-toolchain 文件中。如果没有这个文件，则会使用默认版本（一般是本机的架构的稳定版，x86_64 或 arm64）。例如 Starry 的 rust-toolchain.toml 写的是 [toolchain] profile = \"minimal\" channel = \"nightly\" components = [\"rust-src\", \"llvm-tools-preview\", \"rustfmt\", \"clippy\"] targets = [\"x86_64-unknown-none\", \"riscv64gc-unknown-none-elf\", \"aarch64-unknown-none-softfloat\"] channel = \"nightly\" 意味着这个项目会主动跟随最新的 cargo 版本。这个内核在持续开发中，会及时修正代码中的版本冲突。 而 NPUcore 的 rust-toolchain 写的是 nightly-2022-04-11 这是当年比赛要求使用的版本。直接尝试运行这个内核不会有太大问题，Rust 会自动下载 nightly-2022-04-11 这个版本。但如果你想在这个内核上继续开发，那么为了避免和新的库冲突，最好还是把它换成最新的版本，然后修改必要的特性和代码。 还有一种情况是 Oops，此时内核没有指定 rust-toolchain.toml 或者 rust-toolchain ，因此你在运行它时会默认采用最新的 cargo。但这个内核开发时的环境（指那一年评测机环境和队员的本地环境）其实是 nightly-2022-04-11，所以直接运行时可能会报错。给它加上一个和上面提到的 NPUcore 同样的版本文件可以规避掉这个问题。 评测机和离线编译 平时我们联网编译内核时，包管理器兼编译器 cargo 会根据 Cargo.toml 文件在包管理平台或者指定的 git 仓库下载到本地的 ~/.cargo 目录下作为缓存（除非依赖指定的是本地的路径），然后再进行编译。但在指定离线编译的情况下，包管理器只能找到找本地 ~/.cargo 里有的库和用相对路径指定的库。 至少从前三届的比赛来看，评测机是不联网的。评测机的 ~/.cargo 目录自带一些常用的库，这些库通常会在评测页面列出。但如果内核要用其他的库，就只能把它“复制粘贴”到自己的项目里了。以 FTLOS 为例，它的 Cargo.toml 里就有一些网上开源的库，但因为评测机上没有，所以只能复制到 ../dependencies 目录下使用了。 当然，引发问题的通常不是这些库，而是评测机本地有，但你的本地没有的库。由于指定了离线编译，所以编译器只会在 ~/.cargo 下试图找这些库，找不到时就会报错。此时只要把离线编译关掉就好了。离线编译是通过 --offline 形式指定的。一般来说，如果你看到内核目录的 Makefile 里有 cargo build --offline 那么把 --offline 删掉就可以了，这会迫使 cargo 联网去找这些库。比如 ByteOS 的实现 就是如此。如果内核 Makefile 写得比较花，也可能用其他方式传参，比如 FTLOS 的实现 就是藏在根目录下。你可以全局搜索 --offline 来找这个选项。 默认运行的文件 在比赛中，内核的编译使用的是每个队伍自己代码仓库里的 Makefile，但加载和运行会使用评测机上的脚本。 以大家熟悉的 rCore-Tutorial 为例，make run 时会先编译出一个内核镜像 os.bin，然后这个内核镜像与 RustSBI、文件系统镜像一起作为参数被扔给 Qemu 运行。对应到比赛中，就是评测机先调用项目根目录下 make all 得到 os.bin，然后再用一套自己的脚本去配置实机或 Qemu 并运行。这套脚本与每个队伍代码仓库中的运行方式无关，所以如果你的配置和它不太一样，就可能无法正确运行。例如 2022 年比赛中，评测机会将官方指定的文件系统镜像直接映射到物理内存的 [0x9000_0000, cfff_ffff)，有一些参赛队会默认按这个逻辑实现。 不过，本节开头列出的内核都可以不依赖评测机环境、根据 README 指引生成文件系统镜像并运行。所以只有在运行其他参赛内核时你才需要担心这个问题。 "},"docs/lab3/cache.html":{"url":"docs/lab3/cache.html","title":"探索 cargo 的缓存","keywords":"","body":"探索 cargo 的缓存 部分往届内核及运行指引 提到了 cargo 的离线编译与缓存。Rust 库具体会被 cargo 缓存到哪里呢？ 打开我们前两个实验的 rCore-Tutorial 仓库，在 os/src/main.rs 找到 extern crate log 一行。绝大部分 IDE 都带有“跳转到定义”的功能（或者也可以直接在 ~/.cargo 下搜索），例如 vscode 的： 我们可以通过跳转或者搜索，去看 log 库的代码： 思考题1.1：这些代码具体在 ~/.cargo 下的哪个文件夹？ 临时修改依赖库 找到第 1352 行左右的 set_logger 函数，我们在 rCore-Tutorial 初始化时会调用它。把第一行加个分号 ; ，然后加个 panic，也即改成： pub fn set_logger(logger: &'static dyn Log) -> Result { set_logger_inner(|| logger); panic!(\"123\") } 然后先 make clean 再 make run，可以看到我们的 panic 真的生效了。这意味着如果在 debug 时怀疑依赖库的输出，是可以直接在依赖库里修改的！比如你可以加一些 panic! assert! 这样的判断，或者修改代码的运行逻辑。一般来说你无法在依赖库中 println! 但可以通过向 panic! 传递字符串来实现近似的输出效果。 无论如何，修改依赖库的代码是一件危险的事情。当需要恢复这些修改，可以把代码改回去，也可以直接删掉整个 log 仓库，因为这些仓库只是“缓存”，下次编译时 cargo 还会自动从网络拉取的。当然，别忘了先 make clean 再 make run。 思考题1.2：如果忘记 make clean 会发生什么？ 如果你真的需要修改依赖库 一般来说，我们只会通过这种方式检查依赖库运行的逻辑，以辅助寻找内核中的 bug。如果它本身存在 bug 或者缺少你需要的功能，最好的办法是克隆它的 git 项目，修改后向原作者提出 pull request。或者至少也需要像上一节提到的离线编译那样，在内核项目下开一个类似 dependencies/ 的目录，把对这个模块的依赖变成本地依赖。 "},"docs/lab3/justrun.html":{"url":"docs/lab3/justrun.html","title":"如何使用往届内核","keywords":"","body":"如何使用往届内核 Starry 是 2023年比赛的参赛作品，基于 Arceos 实现，目前仍在更新，运行它几乎不会遇到 部分往届内核及运行指引 一节中提到的问题。 我们会带大家从一个完全陌生的视角了解 Starry，你可以用同样的方式去运行和理解其他内核！。 如果需要引入一些额外的知识，我们会用如下的格式来解释： Starry 只要求安装有 nightly 版本的 rust，以及 qemu-system-riscv64。如果你想用它运行 C 语言编译的测例，还需要在第一个实验中安装的 riscv64-linux-musl- 工具链。 运行 Starry 看根目录下 README.md，在终端中运行 ./build_img.sh sdcard make run 如果顺利的话，会先看到 OpenSBI 的 logo 和一堆参数，接下来是 Arceos 的内核输出： d8888 .d88888b. .d8888b. d88888 d88P\" \"Y88b d88P Y88b d88P888 888 888 Y88b. d88P 888 888d888 .d8888b .d88b. 888 888 \"Y888b. d88P 888 888P\" d88P\" d8P Y8b 888 888 \"Y88b. d88P 888 888 888 88888888 888 888 \"888 d8888888888 888 Y88b. Y8b. Y88b. .d88P Y88b d88P d88P 888 888 \"Y8888P \"Y8888 \"Y88888P\" \"Y8888P\" arch = riscv64 platform = riscv64-qemu-virt target = riscv64gc-unknown-none-elf smp = 1 build_mode = release log_level = warn [ 3.976575 0 fatfs::dir:140] Is a directory [ 8.753755 0 fatfs::dir:140] Is a directory [ 13.505061 0 fatfs::dir:140] Is a directory [ 18.393231 0 fatfs::dir:140] Is a directory [ 23.440344 0 fatfs::dir:140] Is a directory [ 62.351342 0:8 axprocess::signal:128] cpu: 0, task: 8, handler signal: 11 [ 62.365045 0:8 axprocess::signal:90] Terminate process: 7 [ 62.381378 0:6 axprocess::signal:128] cpu: 0, task: 6, handler signal: 17 Simple syscall: 27.7772 microseconds 其余的输出还有很长，看来运行还需要一段时间，此时可以不等它执行完所有测例，直接关掉 Qemu（按 ctrl+A ，松开后按 X）。 替换测例 面对一个全新的内核，我们可以提出许多问题： 它是如何启动的？ 我们熟悉的内核（比如 rCore-Tutorial）里的内存管理、进程、文件系统、异常中断等等功能它也有吗？有什么区别？ 它有没有自己的规范，或者说代码风格？ 但首先应该考虑的是如何替换它运行的测例以便为我们所用。以上一章实验中的 hellostd 测例为例，如果我们能让 Starry 运行这个测例，看一看它执行了哪些 syscall ，再找一找这些 syscall 的实现，就可以轻松秒杀前一章的实验了。 比赛中涉及的大部分内核功能都可以以这种方式实现，只要你的进度还没有超过往届的内核，就可以借鉴它们的写法去通过同样的测例。 修改文件系统镜像 我们的目标是用 Starry 运行上一章实验的 hellostd。 首先观察前面运行时的命令，./build_img.sh sdcard 应该就是制作镜像的步骤了，它指向根目录下的文件 ./build_img.sh： rm disk.img dd if=/dev/zero of=disk.img bs=3M count=24 mkfs.vfat -F 32 disk.img mkdir -p mnt sudo mount disk.img mnt # 根据命令行参数生成对应的测例 sudo cp -r ./testcases/$1/* ./mnt/ sudo umount mnt rm -rf mnt sudo chmod 777 disk.img 这段脚本生成了一个空的镜像文件 disk.img，然后把它挂载到 /mnt，并将所有在 ./testcases/$1/* 下的文件拷贝到了镜像中。我们其实在第一章实验的介绍 中介绍过 FAT32 镜像的生成与挂载。其中 $1 是执行命令 ./build_img.sh sdcard 时的第一个参数，也就是 sdcard。所以被加载到文件系统里的实际上是项目根目录下的 testcases/sdcard/ 里的所有文件。 参考第二章实验的介绍 把 hellostd 这个测例编译出来(在 rCore-Tutorial 那边的 testcases/build/下)，然后复制到 Starry 的 testcases/sdcard/ 文件夹下。然后再运行一次 ./build_img.sh sdcard ，这个测例就在 Starry 的文件系统镜像里了。 寻找运行测例的位置 现在我们想让 Starry 启动时不要运行目前的测例，而是启动 hellostd。 每个内核启动后运行的程序都不太一样，例如 rCore-Tutorial ch8 开机启动的 ch8b_initproc 就藏在 os/src/task/mod.rs 的第一百多行。对于一个陌生的内核（不只是 Starry），通常有以下方式可以找到它启动后执行什么测例： 先看 README.md。 不过 Starry 在这里并没有相关说明。 在具体文档中查找。在 Starry 是 /doc 目录，在其他内核里可能是类似名字的目录，或者 README 中链接到的外部文档。类比 rCore-Tutorial，我们需要搜的是“测例”“启动”“第一个进程”之类的说法。 对于 Starry 来说，可以在 doc/OSCOMP-Repo/启动流程.md 这个文档找到关于 ulib/starry_libax/src/test.rs/run_testcases.rs 的描述。虽然这个路径不在内核中，但只要全局搜索 run_testcases 就可以找到它现在在哪了。 如果你知道这个内核启动时默认在执行什么，也可以直接搜索用户程序的名称。例如启动后出现终端，那很可能是 busybox sh。 对于 Starry 来说，如果你知道它启动后执行的是来自 lmbench 的测例，就可以全局搜索 lmbench。搜出文件稍微有点多，但找两分钟还是能找到谁在控制执行测例的。 否则，可以搜索 _start，找找内核启动的位置，然后找到内核初始化的函数，看第一个用户程序是从哪加载的 对于 Starry 来说，会找到 _start 跳转 rust_entry 再到 rust_main 最后是 main。全词搜索 main() 可以发现几乎都在 apps/* 目录下，最像比赛要求的就是 apps/oscomp/src/main.rs 了。 条条大路通罗马，你只需要用其中一种方式找到启动后执行的测例在哪就行。 思考题2：在部分往届内核及运行指引 一节提到的内核中挑选一个，描述它在默认情况下启动后会执行哪些测例（抑或是直接启动终端）。你不一定要真的运行那个内核，读文档或搜索即可。 替换测例并输出 syscall 日志 通过上面的方法，我们可以找到 Starry 下的 ulib/axstarry/syscall_entry/src/test.rs 中的 run_testcases 函数： pub fn run_testcases(case: &'static str) { fs_init(case); let (mut test_iter, case_len) = match case { \"junior\" => (Box::new(JUNIOR_TESTCASES.iter()), JUNIOR_TESTCASES.len()), \"libc-static\" => ( Box::new(LIBC_STATIC_TESTCASES.iter()), LIBC_STATIC_TESTCASES.len(), ), \"libc-dynamic\" => ( Box::new(LIBC_DYNAMIC_TESTCASES.iter()), LIBC_DYNAMIC_TESTCASES.len(), ), \"lua\" => (Box::new(LUA_TESTCASES.iter()), LUA_TESTCASES.len()), \"netperf\" => (Box::new(NETPERF_TESTCASES.iter()), NETPERF_TESTCASES.len()), \"ipref\" => (Box::new(IPERF_TESTCASES.iter()), IPERF_TESTCASES.len()), \"sdcard\" => (Box::new(SDCARD_TESTCASES.iter()), SDCARD_TESTCASES.len()), \"ostrain\" => (Box::new(OSTRAIN_TESTCASES.iter()), OSTRAIN_TESTCASES.len()), _ => { panic!(\"unknown test case: {}\", case); } }; ...... 回顾我们最初编译文件系统镜像，使用的是 ./build_img.sh sdcard，那应该就是 SDCARD_TESTCASES 这个常量了。在同个源文件下找到它，直接删掉所有项目，改成 pub const SDCARD_TESTCASES: &[&str] = &[ \"hellostd\", ]; 再次 make run 就可以运行我们自己塞进去的测例了。不过 Starry 可以通过比赛要求的所有决赛测例，因此它可以运行 hellostd 这件事没有什么特别的。我们真正想要知道的是它调用了什么 syscall。 找到系统调用的入口，也就是 ulib/axstarry/syscall_entry/src/syscall.rs 的函数 syscall，然后在开头和结尾各加一句 println! 输出。 一般来说，通过文档或者全局搜索 syscall(、sys_ 都能很容易找到一个内核的系统调用模块。有内核把启动过程藏得特别深的，也有把初始进程藏到配置文件的，但处理 syscall 的模块肯定都叫 syscall。 #[no_mangle] pub fn syscall(syscall_id: usize, args: [usize; 6]) -> isize { println!(\"[syscall] id = {}, args = {:?}, entry\", syscall_id, args); #[cfg(feature = \"futex\")] syscall_task::check_dead_wait(); ...... let ans = deal_result(ans); ans println!(\"[syscall] id = {}, args = {:?}, return {}\", syscall_id, args, ans); } 然后 make run 会得到报错： error: cannot find macro `println` in this scope --> ulib/axstarry/syscall_entry/src/syscall.rs:5:5 | 5 | println!(\"[syscall] id = {}, args = {:?}, entry\", syscall_id, args); | ^^^^^^^ error: cannot find macro `println` in this scope --> ulib/axstarry/syscall_entry/src/syscall.rs:42:5 | 42 | println!(\"[syscall] id = {}, args = {:?}, return {}\", syscall_id, args, ans); | 对于大部分的内核来说，直接输出 println! 是可以的。但因为 Starry 是一个模块化程度比较高的内核，所以它的 syscall 模块对于内核来说就像是一个普通的“依赖库”一样（还记得上一节 中我们说不能在依赖库中 println 吗），所以不支持 println!。不过此时我们可以试一试用 error! warn! info! 这些命令，因为 rCore-Tutorial 使用的日志库也是一个非常流行的库。把代码修改成 #[no_mangle] pub fn syscall(syscall_id: usize, args: [usize; 6]) -> isize { error!(\"[syscall] id = {}, args = {:?}, entry\", syscall_id, args); #[cfg(feature = \"futex\")] syscall_task::check_dead_wait(); ...... let ans = deal_result(ans); ans error!(\"[syscall] id = {}, args = {:?}, return {}\", syscall_id, args, ans); } 再次 make run 后报错变成了 error: cannot find macro `error` in this scope --> ulib/axstarry/syscall_entry/src/syscall.rs:5:5 | 5 | error!(\"[syscall] id = {}, args = {:?}, entry\", syscall_id, args); | ^^^^^ | help: consider importing this macro | 1 + use axlog::error; | error: cannot find macro `error` in this scope --> ulib/axstarry/syscall_entry/src/syscall.rs:42:5 | 42 | error!(\"[syscall] id = {}, args = {:?}, return {}\", syscall_id, args, ans); | ^^^^^ | help: consider importing this macro | 1 + use axlog::error; | 编译器提示说可以加上 use axlog::error;。我们在 syscall() 函数前面开始前、 use syscall_utils::deal_result; 之后加上一行声明 use axlog::error;。再次 make run，现在可以成功运行并拿到正确输出了！ Starry 的默认调试输出级别是 warn! 及以上，所以这里用 error! 可以看到输出。它是在根目录下 Makefile 的 LOG ?= warn 这一句设定的。 如果在运行其他内核时没有看到调试输出，可以找找它的 Log 设置，一般都和 rCore-Tutorial 差不多。也有个别内核自己写了一套调试输出方法，不过这样做的队伍一定会在 README.md 告诉你怎么调试的。 为了不给还没做完 lab2 先来看 lab3 实验的同学剧透，这里就不放具体输出内容了。 基于 syscall 的对拍调试以及思考 上面这个方法具体有什么用？知道了测例对应的 syscall 参数和输出，就可以仿照 Starry 去写对应的 syscall，它返回 0 的你也可以返回 0；它使用其他 syscall 代替的你也可以用其他 syscall 代替。这就相当于你有了一份关于 lab2 的参考答案。如果只是看代码，不加 syscall 输出，就可能需要仔细阅读 Starry 的源码才能知道它需要哪些实现。 更进一步，既然我们可以让 Starry 运行 hellostd，自然也能让它运行所有的决赛测例。这样一来，只要你的进度还在比赛要求测例的范围内，就基本不需要担心在同一个测例上卡太久。出现问题时，可以对比往届内核给出的 syscall 参数和返回值和自己内核给出的 syscall 参数和返回值，基本都能快速定位到问题。这种调试方式叫做对拍，如果还有印象的话，我们在第一章的测例库介绍一节的末尾介绍过它。 当然，如何比以前的内核写得效率更高、更模块化、支持更多的功能就是另一个话题了。 大部分初赛测例也可以运行，但因为初赛的 syscall 规范并不是真正的 POSIX syscall，而是做了一定修改，所以不一定能在完成决赛要求的内核上运行。做到决赛的内核都是需要满足 POSIX syscall 规范的。 通过 syscall 输出调试可以解决 80% 的问题，但并不是全部问题。有可能你的内核和往届内核在 syscall 之外的模块有不同，导致只看 syscall 的输出无法完成调试，例如页表和地址空间设置有误，或是没有保存用户程序的浮点寄存器等等。 注意事项 在使用 syscall 输出调试时，还有其他需要注意的地方： 一些 syscall 包含用户空间的数据结构，例如 sys_clock_gettime 就会传一个 TimeSpec 用于获取时间（你可能在 rCore-Tutorial ch4 重写过类似的 syscall）。这时候仅输出地址可能不足以帮助调试，最好还是进到 sys_clock_gettime 里去给它“定制”一句调试输出。 后期的 lmbench 等测例集会反复调用同一个 syscall 几十万甚至百万次，以便测试性能。所以在调试这些测例时，最好不要每次 syscall 都输出一行，否则屏幕很快就会被输出淹没。万一出现这种情况，记得直接关掉 Qemu（按 ctrl+A ，松开后按 X）。 这个问题有一些很暴力的解决方式。比如可以只输出前几十次调用，也可以用一个类似 rCore-Tutorial ch3 的 task_info 的全局计数器，然后同个 syscall 每隔几百几千次调用才输出一次。 有些应用会在没事干的时候反复调用几个 syscall 检查是否有输入信息，或者更新系统时间，例如 redis。在调试这些应用的时候，可以直接用 if 判断特定的 syscall_id ，然后不输出这些 syscall 的调用信息。 另外，上面在修改 Starry 的代码时添加的语句可能会引起你的好奇： 为什么要用 error!，我们只是想拿到一些内核运行的信息，用 info! 或者 debug! 是不是更合适？ 这是因为内核里可能自带很多 Log 输出，如果我们想要的输出等级不够高，可能就会淹没在内核本身的日志输出里，亦或是因为 Log 等级太低根本看不到输出。当然，如果可以的话直接敲 println! 还是更方便一些。 为什么没有添加其他信息，比如调用这个 syscall 的进程和线程 ID？ 是的，完全可以增加这些信息！这一节的内容只是帮助大家以最短的时间去把往届内核用起来，如果你找到了内核里哪里存进程和线程 ID，也可以把它放进输出里。 顺便一提，其实 Starry 的调试输出里有线程 ID，例如 [ 41.956958 0:6 syscall_entry::syscall:7] 指的是在启动后 41.956958 这个时间点，CPU 0 号核心在 TID=6 这个线程上，运行到 syscall_entry::syscall 的第 7 行时打印了输出。 不过 Starry 没说它是线程 ID，我们需要阅读 modules/axlog/ 的代码才能知道这些信息 还有一些问题留作思考题： 思考题3.1：为什么要在开头结尾各输出一句，会不会太过重复？（提示：考虑执行出错的情况，或者 sys_exit ） 思考题3.2：为什么要结尾还要输出一遍 syscall 的完整参数，只输出返回值行不行？（提示：考虑像 sys_yield 这样的 syscall） "},"docs/lab3/ls.html":{"url":"docs/lab3/ls.html","title":"定位 ls 命令存在的问题","keywords":"","body":"定位 ls 命令存在的问题 做了这么多准备，我们终于可以引出本章节的实验了。目前在 467c73f 这个版本的 Starry 中，使用 busybox ls 和 busybox mv 操作时会出现一些问题。类似前两章实验的形式，我们会带着大家修正 busybox ls 的问题，然后将 busybox mv 留作实验任务。 本章节涉及的 ls 和 mv 是两个 Linux 命令 ls 可以列出当前目录下的文件。例如你可以在本机的终端尝试 ls 然后按回车。 mv 表示移动文件，类似于“剪切粘贴+重命名”。例如 mv ./a/b ../c/d 表示将当前目录的 a 子目录下的 b 文件剪切，然后粘贴到到上一级目录的 c 子目录下，命名为 d 文件。 busybox 简介 busybox 是一个工具包，既包含 Shell 命令语言的实现，也包含了一些常用的 Linux 命令。你可以尝试执行 busybox 然后回车，检查它的版本。如果发现本机还没有安装 busybox，可以通过类似指令安装 sudo apt install busybox-static 上述是 apt 包管理器时的安装方式，如果你本机的操作系统使用其他包管理器，可以替换成类似的命令。 static 表示静态链接的版本。如果你直接安装 sudo apt install busybox 也是可以的，那样会得到一个动态链接的版本。在日常使用上，这两个版本没有大的区别。但后续的实验会使用 strace 来调试它的输出，静态的版本的输出会简洁一些，所以我们推荐安装静态版本。 工具包 当我们在执行像 ls mv 这样的指令的时候，实际在执行什么？可以尝试在本机上执行下面的命令 where ls 一般来说输出里会有一项 /bin/ls。我们用 file /bin/ls 检查这个文件的属性，会发现它真的是一个可执行文件。而 busybox 相当于把这些文件都包在一起，运行 busybox ls 的输出相当于运行 ls 的输出，运行 busybox mv 的输出相当于运行 mv 的输出。 其中的区别在于，原本的 ls 是一个独立的文件，但 busybox ls，表示运行 busybox 这个程序，ls 只是它的参数。即 argv[0]=\"busybox\",argv[1]=\"ls\"。 Shell 实现 开一个新终端，然后敲 busybox sh 按回车，你就可以得到一个由 busybox 提供的终端。这个终端可能比本来 Linux 自带的 bash （Ubuntu 下则是 dash）简陋一些，但也已经比 rCore-Tutorial 里用 Rust 写的那个 usershell 强大太多了。你在 bash 下能做的大部分操作也可以在 busybox sh 下完成。 现在可以把这个 busybox 终端关掉了，因为我们将在 Starry 中使用 busybox。 定位问题 首先我们修改 Starry 启动时运行的“测例”为 busybox sh。因为文件系统镜像里包含 testcases/sdcard/，在这个文件夹下确实有 busybox，所以这么运行是没问题的。也即修改 ulib/axstarry/syscall_entry/src/test.rs 的SDCARD_TESTCASES 为 退一万步讲，就算镜像里没有 busybox，你也可以在网上下载 busybox 源码然后用 riscv64-linux-musl-gcc 交叉编译一个出来，放到文件系统镜像对应的目录里。 pub const SDCARD_TESTCASES: &[&str] = &[ \"busybox sh\", ]; 然后记得把上一节中的 syscall 调试输出和 use axlog::error; 注释掉。因为在终端中运行命令会产生大量的 syscall，终端会被输出塞满。 然后 make run 后尝试依次运行（目录和文件名是随意取的，你可以换一个）： busybox ls busybox touch 123 busybox ls busybox mkdir aaa busybox ls 可以观察到 ls 每次的输出都没有变化。看上去好像 touch 创建文件和 mkdir 创建文件夹都失败了。但再执行几条命令呢 echo \"xxx\">>123 busybox ls busybox cat 123 cd aaa busybox pwd cd .. busybox ls 这段命令尝试用 echo 向文件 123 中写入几个字符 xxx，然后用 cat 命令读取文件内容，是可以正确读取的。又尝试进入 aaa 目录并用 pwd 打印当前目录，发现 aaa 目录也是存在的。看来之前的 touch mkdir 应该没问题，有问题的是 ls。 大部分命令都有前缀 busybox 但不是全部。这是因为 Starry 默认把一部分命令软链接到了 busybox，而且在执行文件不存在时尝试把它交给 /busybox （也是 /sh）解析。这些操作是在 ulib/axstarry_syscall_entry/src/test.rs 的 fs_init 函数中完成的。 再仔细对比 busybox ls 的输出和 testcases/sdcard/ 里的内容，会发现其中少了几项。 testcases/sdcard/ 中按字典序排列的最后几个文件在 busybox ls 的输出里是没有的，但我们还是可以用类似上面的命令确认这些文件确实存在。 如果不在根目录下，而是换个文件少的目录，ls 的行为是正常的，可以看到所有创建的文件和目录。 所以 busybox ls 的问题在于它只输出了目录下的部分内容，没有输出全部文件。 只获取 busybox ls 的输出 接下来我们希望单独分析 busybox ls 的 syscall 输出结果。为了避免来自终端 busybox sh 的 syscall 干扰，我们再一次修改 axstarry_syscall_entry/src/test.rs 的SDCARD_TESTCASES 为 pub const SDCARD_TESTCASES: &[&str] = &[ \"busybox ls\", ]; 然后恢复之前注释掉的 use axlog::error; 和 error! 输出，把 error! 换个位置，写成： /// axstarry_syscall_entry/src/syscall.rs use syscall_utils::deal_result; use axlog::error; #[no_mangle] pub fn syscall(syscall_id: usize, args: [usize; 6]) -> isize { #[cfg(feature = \"futex\")] syscall_task::check_dead_wait(); let ans = loop { #[cfg(feature = \"syscall_net\")] { if let Ok(net_syscall_id) = syscall_net::NetSyscallId::try_from(syscall_id) { error!(\"[syscall] id = {:#?}, args = {:?}, entry\", net_syscall_id, args); break syscall_net::net_syscall(net_syscall_id, args); } } #[cfg(feature = \"syscall_mem\")] { if let Ok(mem_syscall_id) = syscall_mem::MemSyscallId::try_from(syscall_id) { error!(\"[syscall] id = {:#?}, args = {:?}, entry\", mem_syscall_id, args); break syscall_mem::mem_syscall(mem_syscall_id, args); } } #[cfg(feature = \"syscall_fs\")] { if let Ok(fs_syscall_id) = syscall_fs::FsSyscallId::try_from(syscall_id) { error!(\"[syscall] id = {:#?}, args = {:?}, entry\", fs_syscall_id, args); break syscall_fs::fs_syscall(fs_syscall_id, args); } } // #[cfg(feature = \"syscall_task\")] { if let Ok(task_syscall_id) = syscall_task::TaskSyscallId::try_from(syscall_id) { error!(\"[syscall] id = {:#?}, args = {:?}, entry\", task_syscall_id, args); break syscall_task::task_syscall(task_syscall_id, args); } } panic!(\"unknown syscall id: {}\", syscall_id); }; let ans = deal_result(ans); error!(\"[syscall] id = {}, args = {:?}, return {}\", syscall_id, args, ans); ans } 可以注意到函数开头的 error! 移动到了 match 的每一项中，并且 syscall_id 的输出从 {} 换成了 {:#?}，这表示输出这个枚举体（即 enum）对应的名字。例如 NetSyscallId 定义为 pub enum NetSyscallId { // Socket SOCKET = 198, BIND = 200, ...... 如果 net_syscall_id 的值是 NetSyscallId::SOCKET，那么 println!(\"{}\", net_syscall_id) 输出 198，而 println!(\"{:#?}\", net_syscall_id) 输出 SOCKET。 这对实际的代码没有影响，只是为了输出 syscall 的名字，让我们看输出更方便。 现在 make run 后可以得到一长串的 syscall 输出，为了简便我们去掉了前缀的输出信息（就是像 58.641175 0:6 syscall_entry::syscall:29 这样的前缀），且只截取其中有意义的部分： ...... 省略进程初始化 [syscall] id = FSTATAT, args = [18446744073709551516, 1230088, 1073740272, 0, 1230088, 18446744073709551516], entry [syscall] id = 79, args = [18446744073709551516, 1230088, 1073740272, 0, 1230088, 18446744073709551516], return 0 [syscall] id = OPENAT, args = [18446744073709551516, 1230088, 622592, 0, 0, 0], entry [syscall] id = 56, args = [18446744073709551516, 1230088, 622592, 0, 0, 0], return 3 [syscall] id = FCNTL64, args = [3, 2, 1, 0, 0, 3], entry [syscall] id = 25, args = [3, 2, 1, 0, 0, 3], return -22 [syscall] id = GETDENTS64, args = [3, 4344, 2048, 0, 0, 4320], entry [syscall] id = 61, args = [3, 4344, 2048, 0, 0, 4320], return 2022 [syscall] id = FSTATAT, args = [18446744073709551516, 6432, 1073740144, 256, 6432, 18446744073709551516], entry [syscall] id = 79, args = [18446744073709551516, 6432, 1073740144, 256, 6432, 18446744073709551516], return 0 ...... 省略若干条 FSTATAT [syscall] id = MMAP, args = [0, 4096, 3, 34, 18446744073709551615, 0], entry [syscall] id = 222, args = [0, 4096, 3, 34, 18446744073709551615, 0], return 8192 [syscall] id = FSTATAT, args = [18446744073709551516, 8032, 1073740144, 256, 8032, 18446744073709551516], entry [syscall] id = 79, args = [18446744073709551516, 8032, 1073740144, 256, 8032, 18446744073709551516], return 0 ...... 省略若干条 FSTATAT [syscall] id = GETDENTS64, args = [3, 4344, 2048, 2022, 2022, 4320], entry [syscall] id = 61, args = [3, 4344, 2048, 2022, 2022, 4320], return 0 [syscall] id = CLOSE, args = [3, 0, 0, 0, 0, 0], entry [syscall] id = 57, args = [3, 0, 0, 0, 0, 0], return 0 [syscall] id = IOCTL, args = [1, 21523, 1073740360, 1, 1073740399, 1454544], entry [syscall] id = 29, args = [1, 21523, 1073740360, 1, 1073740399, 1454544], return 0 [syscall] id = WRITEV, args = [1, 1073740272, 2, 1, 1073740399, 1461432], entry arithoh fstime max_min.lua [syscall] id = 66, args = [1, 1073740272, 2, 1, 1073740399, 1461432], return 87 ...... 省略若干条 WRITEV，这里是 ls 对终端的输出 [syscall] id = EXIT_GROUP, args = [0, 0, 0, 1459768, 0, 0], entry 上一节如何使用往届内核提到，当我们不知道一个功能如何实现时，可以先看看往届内核的 syscall 输出进行对拍。但如果我们要调试往届内核的错误呢？答案是找 Linux 的 syscall 输出对拍。 "},"docs/lab3/strace.html":{"url":"docs/lab3/strace.html","title":"strace 简介","keywords":"","body":"strace 简介 我们之所以大费周章把 syscall 调用的信息都列出来，就是为了向大家介绍使用 strace 工具进行调试的方法。strace 是 Linux 下的一个调试分析工具，可以追踪程序运行时调用的 syscall 和可接收的信号。 通常来说，如果一个测例无法通过，我们可以直接看测例的源代码，找找哪一行出的问题。但如果源代码太长或者根本不可读，strace 就非常有用。如果发现本机还没有安装 strace，可以通过类似指令安装 sudo apt install strace 上述是 apt 包管理器时的安装方式，如果你本机的操作系统使用其他包管理器，可以替换成类似的命令。 的使用方式很简单，直接把 strace 加在要运行的命令之前，它就会自动输出所有运行过程中的 syscall。例如在本机上运行 strace touch a 就能看到创建文件 a 过程中 touch 这个用户程序执行的所有 syscall。 strace 也可以加一些参数，常用的有 -c 按种类统计 syscall 的执行时间、次数和报错次数。注意，“报错”只是代表返回小于 0 的错误码，不代表用户程序出错。例如检查文件是否不存在时也可以用 sys_openat ，得到 ENOENT（没有此文件）的结果属于“报错”，但这就是我们预期的结果。 -p 表示指定追踪的进程ID。如果想调试一个大的应用程序，可能会有许多进程共同协作，我们可以指定关心某一个 -t 输出时间信息；-T 显示每次调用的时间 -f 追踪 fork；-F 追踪 fork 和 vfork -e [!]value1[,value2] 指定要追踪的 syscall，如 -e clone,read 就是只看 sys_clone 和 sys_read。反之，前面加感叹号 ! 表示不追踪对应的 syscall 一些终端的实现会将 ! 理解为其他含义，因此在表达式中使用时需要加反斜杠 \\ 转义。例如不看 sys_read 就是 -e \\!read 更多参数可以通过 strace -h 或者 man strace 查看。 在比赛中，用 strace 调试的好处是可以得到一个来自 Linux 的“标准答案”，而往届内核只能算是“优秀学生作业”。但 strace 只给出答案不给出解题过程，所以你还是有必要阅读往届内核的代码。由于 riscv64 架构和本机不同，我们可以有很多种使用 strace 的不同方式 在 linux-riscv64 中运行 比赛测例仓库提供了一种编译 riscv64 架构的 linux 的方法。你可以按照比赛文档的描述，编译一个 linux，然后把它放到 Qemu 中运行，就像在 Qemu 中运行 rCore-Tutorial 和 Starry 一样。然后在这个 linux-riscv64 中联网下载 strace，并把测例都传到里面，就可以在里面用 strace 调试所有测例了。 这样做的好处是调试本身很方便，但是编译 Linux、配置 qemu-riscv64 中的环境、传数据的过程相对比较麻烦。而且 Qemu 里运行一个 Linux 的效率会比较低。 在 qemu-riscv64 中运行静态链接测例 第一章的测例库介绍一节的末尾介绍过用户态的 qemu。我们可以直接用 strace 来调试它，例如对应第二章的测例可以用 strace qemu-riscv64 hellostd。 为了不给还没做完 lab2 先来看 lab3 实验的同学剧透，这里就不放具体输出了。 这样做的好处是不用重新配环境去编译 Linux 了，但是输出本质上是 qemu-riscv64 这个程序对我们本机调用的 syscall ，而不是 hellostd 对 qemu-riscv64 模拟的内核调用的 syscall。好在 qemu-riscv64 会直接把绝大部分的 syscall 直接翻译转到本机，所以抛开前面一长串 qemu-riscv64 的初始化，你还是可以在输出的最后看到第二章实验中熟悉的 syscall。 在 qemu-riscv64 中运行动态链接测例 如果想用这个方式运行动态链接的测例，会遇到一些小麻烦。具体来说，比赛的测例仓库的libc-test 说明会告诉你动态编译的测例需要依赖一个叫 libc.so 的动态库文件。所以用 qemu-riscv64 运行动态链接测例时，qemu-riscv64 会发现缺失这个动态库，然后去本机的 /bin/libc.so 找这个文件。 一般来说，本机是 x86_64 或者 arm64 架构，不会在 /bin 下放一个 riscv64 的可执行文件。但如果按照libc-test 说明里把提到的 /lib/ld-musl-riscv64-sf.so.1 放到 /bin 下命名为 libc.so，确实是可以成功运行测例的。 当然，如果不想这样破坏本机的环境也有办法。可以使用 maturin 提供的这个模块 编译动态的 libc-test 测例，然后把 libc.so 和其他动态库复制到你运行 qemu-riscv64 的同目录下即可。例如你想在本机的 ./build 下运行动态链接的测例，就把这个模块里提供的所有 .so 复制一份到 ./build 目录下，然后 cd build 再执行 strace qemu-riscv64 ... 即可。 这个方法之所以有效，是因为在模块的 Makefile 下编译时指定了动态库的地址 #动态测例 %.dout : %.c $(CC) $(LDFLAGS) $(CFLAGS) $^ -DDYNAMIC $(COMMON_SRCS) -Lsrc/functional -Lsrc/regression -ltls_align_dso -ltls_init_dso -ldlopen_dso -ltls_get_new-dtv_dso -Wl,-rpath ./ -o $@ mkdir -p build cp $@ $(addprefix build/, $(subst -,_,$(notdir $@))) 其中 -Wl,-rpath ./ 就是告诉编译器，编译出的动态链接测例去 ./ 目录找动态库，而不是去根目录或者 /bin 在本机运行 涉及具体文件操作时，上面的方法就不一定管用了，因为 qemu-riscv64 只是运行一个测例文件，没有加载文件系统镜像。 例如我们目前遇到的 busybox ls 的问题，只好在本机 x86_64 或者 arm64 上试一试用 strace 调试相同的命令看结果如何了。当然此时 busybox ls 的行为不一定和 riscv64 的一致，但还是可以利用它的输出来辅助我们的判断。 下一节，我们会实际用这种方式来调试当前的 bug。 "},"docs/lab3/lsdebug.html":{"url":"docs/lab3/lsdebug.html","title":"使用 strace 调试","keywords":"","body":"使用 strace 调试 在本节中，我们会使用 strace 分析 busybox ls 的输出，并利用这一点找出为什么内核的 busybox ls 没有显示所有的目录文件。 本节会大量修改 Starry 下 ulib/axstarry/syscall_fs/src/imp/ctl.rs 的代码，你不需要跟着修改，可以在这里获取同名的 ctl.rs 文件，然后替换掉原本的 ctl.rs。 注意：写作本节指导书时，使用的环境是 Ubuntu 22.04，busybox 的版本是静态链接的 v1.30.1 (Ubuntu 1:1.30.1-7ubuntu3)。如果你的环境不太一样，输出可能会略有不同，但原理是相通的。 事实上靠 strace 调试 busybox ls 比较难，反而是调试本章实验要求做的 busybox mv 要更容易一些，所以你可能会觉得本节的调试过程有一点别扭和繁琐。但正因为调 busybox ls 更难，所以我们把它放在了指导书里而不是留作作业。 尝试在本机上获取 strace 输出 你可以按上一节提到的方法在 riscv64-linux 下测试，会得到更干净的输出。但为了实验简便，我们这里演示直接在本机上测试的思路。 运行 Starry 时执行 ls 的根目录在 Starry 代码目录的 testcases/sdcsrd/。我们在本机这个目录下运行 strace busybox ls 可以得到以下输出 ...... 省略进程初始化 newfstatat(AT_FDCWD, \".\", {st_mode=S_IFDIR|0755, st_size=4096, ...}, 0) = 0 openat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3 newfstatat(3, \"\", {st_mode=S_IFDIR|0755, st_size=4096, ...}, AT_EMPTY_PATH) = 0 getdents64(3, 0x14d2850 /* 76 entries */, 32768) = 2632 newfstatat(AT_FDCWD, \"./arithoh\", {st_mode=S_IFREG|0755, st_size=112544, ...}, AT_SYMLINK_NOFOLLOW) = 0 newfstatat(AT_FDCWD, \"./syscall\", {st_mode=S_IFREG|0755, st_size=117864, ...}, AT_SYMLINK_NOFOLLOW) = 0 ...... 省略若干条 newfstatat getdents64(3, 0x14d2850 /* 0 entries */, 32768) = 0 close(3) = 0 newfstatat(1, \"\", {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x3), ...}, AT_EMPTY_PATH) = 0 write(1, \"arithoh execl \"..., 78arithoh execl lmbench_testcode.sh short ) = 78 ...... 省略若干条 write exit_group(0) = ? 浏览一下上面各个 syscall 的文档，可以找到 getdents64 就是获取目录下各个文件名的 syscall，它很可能有问题，但在此之前，我们还是先对比一下在 “定位 ls 命令存在的问题”一节 末尾的给出的内核输出： ...... 省略进程初始化 [syscall] id = FSTATAT, args = [18446744073709551516, 1230088, 1073740272, 0, 1230088, 18446744073709551516], entry [syscall] id = 79, args = [18446744073709551516, 1230088, 1073740272, 0, 1230088, 18446744073709551516], return 0 [syscall] id = OPENAT, args = [18446744073709551516, 1230088, 622592, 0, 0, 0], entry [syscall] id = 56, args = [18446744073709551516, 1230088, 622592, 0, 0, 0], return 3 [syscall] id = FCNTL64, args = [3, 2, 1, 0, 0, 3], entry [syscall] id = 25, args = [3, 2, 1, 0, 0, 3], return -22 [syscall] id = GETDENTS64, args = [3, 4344, 2048, 0, 0, 4320], entry [syscall] id = 61, args = [3, 4344, 2048, 0, 0, 4320], return 2022 [syscall] id = FSTATAT, args = [18446744073709551516, 6432, 1073740144, 256, 6432, 18446744073709551516], entry [syscall] id = 79, args = [18446744073709551516, 6432, 1073740144, 256, 6432, 18446744073709551516], return 0 ...... 省略若干条 FSTATAT [syscall] id = MMAP, args = [0, 4096, 3, 34, 18446744073709551615, 0], entry [syscall] id = 222, args = [0, 4096, 3, 34, 18446744073709551615, 0], return 8192 [syscall] id = FSTATAT, args = [18446744073709551516, 8032, 1073740144, 256, 8032, 18446744073709551516], entry [syscall] id = 79, args = [18446744073709551516, 8032, 1073740144, 256, 8032, 18446744073709551516], return 0 ...... 省略若干条 FSTATAT [syscall] id = GETDENTS64, args = [3, 4344, 2048, 2022, 2022, 4320], entry [syscall] id = 61, args = [3, 4344, 2048, 2022, 2022, 4320], return 0 [syscall] id = CLOSE, args = [3, 0, 0, 0, 0, 0], entry [syscall] id = 57, args = [3, 0, 0, 0, 0, 0], return 0 [syscall] id = IOCTL, args = [1, 21523, 1073740360, 1, 1073740399, 1454544], entry [syscall] id = 29, args = [1, 21523, 1073740360, 1, 1073740399, 1454544], return 0 [syscall] id = WRITEV, args = [1, 1073740272, 2, 1, 1073740399, 1461432], entry arithoh fstime max_min.lua [syscall] id = 66, args = [1, 1073740272, 2, 1, 1073740399, 1461432], return 87 ...... 省略若干条 WRITEV，这里是 ls 对终端的输出 [syscall] id = EXIT_GROUP, args = [0, 0, 0, 1459768, 0, 0], entry 可以看到还是有些不一样的地方。不过我们可以通过第二章通过 Manual Page 添加 Syscall一节的方法，去依次检查两个输出不一样的地方，并尝试给出解释： Starry 的 FSTATAT 和本机的 newfstatat 是同一个 syscall 吗？ 是的。在 Starry 全局搜索 FSTATAT 可知调用号是 79。在riscv linux syscall列表 中可以查到 79 号就是 newfstatat。 这个 syscall 的文档说它是 stat, fstat, lstat, fstatat - get file status，是一个获取文件信息的 syscall。 Starry 的是 FSTATAT 输出中反复出现 18446744073709551516，本机输出中 newfstatat 反复出现 AT_FDCWD，它们是一样的吗？ 是的。在 Starry 全局搜索 AT_FDCWD 可以找到这个常量的定义是 -100，它写成 64 位无符号数就变成了一个输出里的那个数。同样在stat的文档 可以搜到这个常量表示的是“当前路径”。 比起内核的输出，本机 strace 的输出的可读性要高上不少，这是因为我们粗暴地在 ulib/axstarry/syscall_entry/src/syscall.rs 里以无符号数的形式输出了每个 syscall 的所有参数。如果我们想让内核输出的可读性更强，可以改为在每一个具体的 syscall 函数内部添加输出。 如果一个参数是数字，可以直接用 println!(\"{}\",a); 输出；如果参数是地址，那么可以用 println!(\"{:x}\",a); 获得十六进制输出；如果参数包含各种符号位（通常用 bitflags 依赖库），或者是枚举体（通常用 numeric-enum-macro 依赖库），可以用 println!(\"{:#?}\",a); 输出。 ? 表示将输出交给 Debug 方法而不是 Display 方法执行。如果内核里定义了新的结构体，也可以 impl Debug for ... 来自定义独特的输出方式。 syscall 调用中还有对不上的地方：使用 open 打开当前目录后，本机输出一条文件名为空的 newfstatat，内核输出一条 FCNTL64；使用 close 关闭当前目录后，内核输出了一条 IOCTL。是它们影响了输出结果吗？ 这些不一致不影响结果。 一样可以查 syscall 文档得知带 AT_EMPTY_PATH 参数且文件名为空时，newfstatat 查询的是第一个参数代表的文件标识符指向的目录。在这个例子中是 3，也就是上一条 open 打开的文件。 在 Starry 全局搜索 fcntl64 （最好能对照 syscall 文档）可知这条 syscall 的含义是对给出的文件标识符 3 设置 F_SETFD，也即如果发生 sys_exec，那么新进程会关闭这个文件标识符，也就是上一条 open 打开的文件。后续调用没有 exec 所以它没有任何影响。 在 Starry 全局搜索 ioctl，可以找到它的实现。这条控制命令是针对文件描述符 1 也就是标准输出的，和目录文件无关。如果再仔细找找，还能找到参数 21523 对应常量 TIOCGWINSZ，也就是窗口长宽，这就是为什么 Starry 中的 ls 输出成三列。 内核输出里在一堆 FSTATAT 中间有一条 mmap，本机输出没有。而且两边的 getdents64 的参数有些不太一样。 这里就需要仔细分析了 进一步检查 syscall 原因和参数 如果你还记得 rCore-Tutorial ch4 的话，mmap 的作用是申请一块内存映射。查 mmap 的 syscall 文档可知，第一个参数即起始地址 addr=0 时，表示由内核决定一个映射位置（见第二段开头） mmap() creates a new mapping in the virtual address space of the calling process. The starting address for the new mapping is specified in addr. The length argument specifies the length of the mapping (which must be greater than 0). If addr is NULL, then the kernel chooses the (page-aligned) address at which to create the mapping; this is the most portable method of creating a new mapping. ...... 也就是说用户程序只是单纯想多要一块空间存东西，地址由内核随便给。申请新的空间说明肯定是旧的什么地方“不够了”，而 getdents64 的作用就是获取目录下各个文件名的 syscall，是不是它导致的呢？查 getdents 的文档可知： long syscall(SYS_getdents, unsigned int fd, struct linux_dirent *dirp, unsigned int count); ...... getdents() The system call getdents() reads several linux_dirent structures from the directory referred to by the open file descriptor fd into the buffer pointed to by dirp. The argument count specifies the size of that buffer. ...... The getdents64() system call is like getdents(), except that its second argument is a pointer to a buffer containing structures of the following type: struct linux_dirent64 { ino64_t d_ino; /* 64-bit inode number */ off64_t d_off; /* 64-bit offset to next structure */ unsigned short d_reclen; /* Size of this dirent */ unsigned char d_type; /* File type */ char d_name[]; /* Filename (null-terminated) */ }; ...... RETURN VALUE On success, the number of bytes read is returned. On end of directory, 0 is returned. On error, -1 is returned, and errno is set to indicate the error. 其中三个参数分别是文件描述符、一组 linux_dirent64 结构体地址与 buffer（缓冲区）大小，而返回值是获取了多少个 Byte 的信息。对比本机与 Starry 的输出 # 本机 getdents64(3, 0x14d2850 /* 76 entries */, 32768) = 2632 # Starry 输出 [syscall] id = GETDENTS64, args = [3, 4344, 2048, 0, 0, 4320], entry [syscall] id = 61, args = [3, 4344, 2048, 0, 0, 4320], return 2022 我们终于找到了问题所在： 本机的busybox 调用时给的 buffer 大小是 32768，一次获取了 2632 Byte 的信息就直接输出了； Starry 下使用比赛官方给的 riscv64 下的 busybox，调用时给的 buffer 大小是 2048，一次获取不完，只拿了 2022 Byte。然后用 mmap 申请一次内存，再次调用 getdents64 时就没有拿到输出了。 其实这时就可以去尝试修改内核中 sys_getdentes64 的实现了，但也可以再想想：在调用前 busybox 也不知道目录下有多少文件，所以这个 buffer 无论是大是小都是个定值。那如果本机的目录下有超过 32768 Byte 的信息，busybox 是怎么处理的呢？ 我们在本机任意位置新建一个目录，然后塞 1500 个空文件进去 mkdir temp cd temp for i in {1..1500}; do touch $i; done 然后用 strace 查看结果。注意，因为这些文件会触发大量获取文件信息的 newfstatat 以及最后输出的 write，我们可以利用strace 介绍一节中提到的参数，屏蔽这两个 sycall。输入命令： strace -e trace=\\!newfstatat,write busybox ls 除去进程启动和来自 ls 命令本身的输出之外，可以看到以下 syscall 信息： ...... 省略进程初始化 openat(AT_FDCWD, \".\", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3 getdents64(3, 0x250e850 /* 1365 entries */, 32768) = 32760 brk(0x2550000) = 0x2550000 getdents64(3, 0x250e850 /* 137 entries */, 32768) = 3288 getdents64(3, 0x250e850 /* 0 entries */, 32768) = 0 close(3) = 0 sysinfo({uptime=143511, loads=[3648, 3584, 5408], totalram=16683806720, freeram=8925274112, sharedram=73728, bufferram=323186688, totalswap=4294967296, freeswap=4294967296, procs=621, totalhigh=0, freehigh=0, mem_unit=1}) = 0 ...... ls 本身的输出 exit_group(0) = ? 可以看到一次 getdents64 拿不完信息的情况下，本机的 busybox 用 brk 这个 syscall 扩展了自己的数据段大小，然后又调用了两次 getdents64。而且每次调用 getdents64 时提供的地址都是相同的，但拿到的 entries 项不一样。就像是用户程序拿着 buffer 问内核“目录下有没有文件”，内核说“这有1365个”；用户又问“还有没有”，内核说“还有137”个；用户又问“还有吗”，内核说“没有了”。 我们没有解释为什么 brk 和 mmap 的作用相同且不影响运行，把它当作已知结论即可。你也可以通过网络搜索得到这个结论。 对比内核输出的两条 GETDENTS64： [syscall] id = GETDENTS64, args = [3, 4344, 2048, 0, 0, 4320], entry [syscall] id = 61, args = [3, 4344, 2048, 0, 0, 4320], return 2022 [syscall] id = GETDENTS64, args = [3, 4344, 2048, 2022, 2022, 4320], entry [syscall] id = 61, args = [3, 4344, 2048, 2022, 2022, 4320], return 0 相当于用户程序拿着 buffer 问内核“目录下有没有文件” 的时候把 buffer 装满了；但第二次再问时明明还有文件要输出，内核却说“没有了”。看来是第二次 GETDENTS64 的返回不对，我们可以由此去修改 ulib/axstarry/syscall_fs/src/imp/ctl.rs 中的 sys_getdents64 函数。 修改代码实现 相比排查错误原因，具体修改代码这部分比较简单，我们会讲的简略一些。 检查 sys_getdents 我们在 sys_getdents 中插入调试输出，看第二次 GETDENTS64 是怎么返回 0 的 /// ulib/axstarry/syscall_fs/src/imp/ctl.rs pub fn syscall_getdents64(fd: usize, buf: *mut u8, len: usize) -> SyscallResult { let path = if let Some(path) = deal_with_path(fd, None, true) { path } else { return Err(SyscallError::EINVAL); }; let process = current_process(); // 注意是否分配地址 let start: VirtAddr = (buf as usize).into(); let end = start + len; if process.manual_alloc_range_for_lazy(start, end).is_err() { return Err(SyscallError::EFAULT); } let entry_id_from = unsafe { (*(buf as *const DirEnt)).d_off }; if entry_id_from == -1 { // 说明已经读完了 error!(\"is here?\"); return Ok(0); } ...... error!(\"or here?\"); Ok(count as isize) } 可以找到是 if entry_id_from == -1 的判断里返回 0，也就是第一个 DirEnt 结构体的 d_off 一项的值为 -1 导致的。它应该是什么？查 gendents 文档可知内核里的 DirEnt 对应规范里的 linux_dirent64 long syscall(SYS_getdents, unsigned int fd, struct linux_dirent *dirp, unsigned int count); ...... struct linux_dirent64 { ino64_t d_ino; /* 64-bit inode number */ off64_t d_off; /* 64-bit offset to next structure */ unsigned short d_reclen; /* Size of this dirent */ unsigned char d_type; /* File type */ char d_name[]; /* Filename (null-terminated) */ }; 也就是说 d_off 是这个缓冲区里到下一个结构的偏移。可以看 syscall 文档下面的解释，或者我们简单举个例子：假设目录里有三个文件 a b c，存进 linux_dirent64 里各占 21 Byte，那么 a 放在 dirp[0]，b 放在 dirp[21] ，c 放在 dirp[42]。所以 a 的 d_off 是 21，b 的 d_off 是 42。 修改 DirEnt 的实现 现在第二次调用 GETDENTS64 时内核里看到的 d_off 为 -1，这个值是谁给的呢？在 Starry 全局搜索 d_off，可以找到下面这个结构定义 /// util/axstarry/syscall_utils/src/ctypes impl DirEnt { /// 定长部分大小 pub fn fixed_size() -> usize { 8 + 8 + 2 + 1 } /// 设置定长部分 pub fn set_fixed_part(&mut self, ino: u64, _off: i64, reclen: usize, type_: DirEntType) { self.d_ino = ino; self.d_off = -1; self.d_reclen = reclen as u16; self.d_type = type_ as u8; } } 原来罪魁祸首在这里：sys_getdents 函数调用了这里的 set_fixed_part，导致 d_off 的值为 -1。 于是我们可以修改这个文件中的目录项的 d_off: i64 定义为 d_off: u64，然后修改 set_fixed_part 函数： /// 目录项 #[repr(C)] #[derive(Clone, Copy)] pub struct DirEnt { /// 索引结点号 pub d_ino: u64, /// 到下一个dirent的偏移 pub d_off: u64, /// 当前dirent的长度 pub d_reclen: u16, /// 文件类型 pub d_type: u8, /// 文件名 pub d_name: [u8; 0], } ...... impl DirEnt { /// 定长部分大小 pub fn fixed_size() -> usize { 8 + 8 + 2 + 1 } /// 设置定长部分 pub fn set_fixed_part(&mut self, ino: u64, off: u64, reclen: usize, type_: DirEntType) { self.d_ino = ino; self.d_off = off; self.d_reclen = reclen as u16; self.d_type = type_ as u8; } } 修改 sys_getdents 的语义和实现 之前这个函数的大致流程是 检查 d_off 是否为 -1，是则直接返回 0 依次枚举目录项，尝试放进 DirEnt （即 linux_dirent64 结构）里，并将 d_off 参数设置为 -1。如果发现用户程序给的 buffer 塞不下了，就退出循环 将“上一步向 buffer 里一共填了多少 Byte” 作为返回值 我们除了将第二步的每个目录项的 d_off 设置成正确语义之外，还要考虑一个问题：下次用户还是拿着同样的 buffer 问内核“目录下有没有文件”，但此时 buffer 里已经填满了上次内核给的输出，怎么办？ 这个问题有很多种解法。我们给出的代码使用这样一种方案： 内核填 buffer 时，留够空间在最后放一个 reclen（即目录项大小）为0，d_off 为 -1 的空项，类似字符串的 '\\0'。 每次 sys_getdents64 先检查这个空项前的所有 DirEnt，找它们之中谁的 d_off 最大，记作 all_offset，这样小于等于这个 all_offset 的目录项都可以认为之前已经输出过了。 枚举每个目录项，计算如果把它放进 buffer 那么 d_off 将是多少。如果小于 all_offset，就跳过这一项，不实际填进 buffer。 buffer 填满时（记得留空间放最后的空项），就退出循环 用上面的流程代替原本的第二步，就可以完成 sys_getdents 从而修复 busybox ls 命令存在的问题了。修改的代码比较复杂，我们将修改后的代码文件 ulib/axstarry/syscall_fs/src/imp/ctl.rs 直接放在了测例仓库的 lab3 分支，你可以用它直接替换 Starry 中的同名文件。 "},"docs/lab3/exercise.html":{"url":"docs/lab3/exercise.html","title":"练习","keywords":"","body":"练习 编程作业 本实验使用 Starry 内核。你可以 fork 这个代码仓库：https://github.com/Azure-stars/Starry，然后在 467c73f 建立一个新分支： git checkout 467c73f git checkout -b lab3 随后就可以开始了。 事先准备 跟随指导书的使用 strace 调试一节，修改位于 ulib/axstarry/syscall_utils/src/ctypes.rs 的 struct DirEnt 的定义和 set_fixed_part 函数。 在这里可以获取到本次实验需要使用的代码和用户程序，其中有两个代码文件需要替换掉 Starry 中的同名文件。 你还可以跟随指导书修改内核运行的测例、添加调试输出等等，但这不是必须的。在内核里修改的文件会被记录到文件系统镜像中，如果你想复原最初的 testcases/sdcard/ 的内容，可以在 make run 前执行 ./build_img.sh sdcard。 在 Starry 全局搜索 LAB3 可以找到要增加的 syscall 功能。但除了它以外，其他文件也有需要修改的地方，但没有 LAB3 标识。 实验3.1 修改 ulib/axstarry/syscall_entry/src/test.rs 的SDCARD_TESTCASES 常量为： #[allow(dead_code)] pub const SDCARD_TESTCASES: &[&str] = &[ \"busybox touch abc\", \"busybox mv abc bin/\", \"busybox ls bin/abc\", ]; 其中不能正常工作的命令是 busybox mv abc bin/。busybox touch 用于创建文件 abc，busybox ls bin/abc 用于检查文件 bin/abc 是否存在。你的任务是修改代码，使得 busybox ls bin/abc 正常输出 bin/abc。 如果你觉得调试过于困难，可以看看下一页的提示。 实验3.2 修改 ulib/axstarry/syscall_entry/src/test.rs 的SDCARD_TESTCASES 常量为： #[allow(dead_code)] pub const SDCARD_TESTCASES: &[&str] = &[ \"busybox touch def\", \"busybox mv def bin\", \"busybox ls bin/def\", ]; 其中不能正常工作的命令是 busybox mv def bin。它和实验3.1的区别在于，bin 目录后没有斜线 /。你的任务是修改代码，使得 busybox mv def bin 正常输出 bin/def。 如果你觉得调试过于困难，可以看看下一页的提示。 问答作业 本章的问答作业是藏在指导书中的几个思考题： 思考题1.1 思考题1.2 在“探索 cargo 的缓存”一节的末尾 思考题2 在“如何使用往届内核”一节的寻找运行测例的位置段落中 思考题3.1 思考题3.2 在“如何使用往届内核”一节的末尾 报告要求 完成编程作业，描述实现思路以及修改的代码。本章没有自动评测，我们会人工检查你的代码实现和报告。 完成问答题。 推荐使用 markdown 格式 和 rCore-Tutorial 实验类似，报告放在 reports/文件夹下，但命名为 labr3.md或labr3.pdf "},"docs/lab3/hint.html":{"url":"docs/lab3/hint.html","title":"实验提示","keywords":"","body":"实验提示 总体提示 在内核里修改的文件会被记录到文件系统镜像中，如果你想复原最初的 testcases/sdcard/ 的内容，可以在 make run 前执行 ./build_img.sh sdcard。 你可以使用 axlog 提供的 error! warn! info! 等输出，如果希望修改输出的等级，可以看看根目录下 Makefile 中的 LOG 常量。 Starry 的代码量很大，如果不知道从哪里下手，先试试本章教学的 strace 方法，只看可能出问题的 syscall 和它们调用的函数。 你可以把 SDCARD_TESTCASES 常量改为 busybox sh，然后亲自进入终端调试。 Starry 的设计文档可能会对你了解这个内核有一些帮助 实验比指导书中介绍的与 busybox ls 相关的调试要简单，看 strace 找原因也比较直接，最靠近报错输出的那一两个就是答案，不会要求大家分析大量 syscall。 流程提示 首先，记得按实验要求修改 SDCARD_TESTCASES常量。 使用定位 ls 命令存在的问题一节中提到的 syscall 输出，直接 make run 运行，mv 会给出如下报错信息 mv: can't stat 'bin/abc': No error information 看看在这条信息的前面有哪些 syscall。然后在你的本机随便找个地方运行 strace 测试类似的命令： mkdir bin touch abc strace busybox mv abc bin/ 对比一下，哪个 syscall 的返回值可能有问题？你只需要修改一行代码，也可以顺手把附近有相同错误的另一行也改了。 此时 mv 会报错： mv: can't rename 'abc': Operation not permitted 这是因为位于 ulib/axstarry/syscall_fs/src/imp/ctl.rs 的 syscall_renameat2 其实只是个空壳，还没有实现。你需要参考syscall 说明 完成它。 在我们给出的 ctl.rs 中已经包含了一些额外的提示信息。 在做到第二个编程任务时，可以再次用 strace，尝试理解它的 syscall 输出： Linux 下的 busybox 是怎么区分 bin 和 bin/ 的，它怎么知道我们想要把 def 放到 bin/def 目录下，而不是重命名成一个叫 bin 的文件？而内核做错了哪里？ 只需要改一个文件的一处代码，需要 5 行左右的修改。 "}}